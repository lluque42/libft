.TH "include/ft_file.h" 3 "Sun Jul 21 2024" "Version 2024-07-21" "Library libft" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/ft_file.h
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBft_putchar_fd\fP (char c, int fd)"
.br
.RI "\fBft_putchar_fd\fP -- \&.TODO\&. "
.ti -1c
.RI "void \fBft_putstr_fd\fP (char *s, int fd)"
.br
.RI "\fBft_putstr_fd\fP -- \&.TODO\&. "
.ti -1c
.RI "void \fBft_putendl_fd\fP (char *s, int fd)"
.br
.RI "\fBft_putendl_fd\fP -- \&.TODO\&. "
.ti -1c
.RI "void \fBft_putnbr_fd\fP (int n, int fd)"
.br
.RI "\fBft_putnbr_fd\fP -- \&.TODO\&. "
.ti -1c
.RI "int \fBft_putchar_fd_safe\fP (char c, int fd)"
.br
.RI "\fBft_putchar_fd_safe\fP -- TODO\&.\&. "
.ti -1c
.RI "int \fBft_putstr_fd_safe\fP (char *s, int fd)"
.br
.RI "\fBft_putstr_fd_safe\fP -- TODO\&. "
.ti -1c
.RI "char * \fBft_gnl\fP (int fd)"
.br
.RI "\fBft_gnl\fP -- Get next line from file descriptor\&. "
.ti -1c
.RI "void \fBft_free_gnl\fP (int fd)"
.br
.RI "\fBft_free_gnl\fP -- Frees allocated memory by \fBft_gnl()\fP related to previous calls on a specific file descriptor\&. "
.in -1c
.SH "Detailed Description"
.PP 
File manipulation related functions\&. Part of libft library\&. 
.SH "Function Documentation"
.PP 
.SS "void ft_free_gnl (int fd)"

.PP
\fBft_free_gnl\fP -- Frees allocated memory by \fBft_gnl()\fP related to previous calls on a specific file descriptor\&. After calling for the first time \fBft_gnl()\fP on a file descriptor, memory is allocated indirectly associated to its static variable\&. If the caller doesn't keep calling \fBft_gnl()\fP until it returns NULL, that memory is never freed and it is reported by Valgrind as a 'still reachable' pseudo leak\&. The \fBft_free_gnl()\fP function solves that by calling \fBft_gnl()\fP on the file descriptor until it returns NULL, while freeing every returned line in the mean time\&. Note that if \fBft_gnl()\fP is called on more than one file descriptor this function must also be called on them\&.
.PP
\fBParameters\fP
.RS 4
\fIfd\fP - An int value representing the file descriptor to read from\&.
.RE
.PP
\fBWarning\fP
.RS 4
EXTERNAL FUNCTION USED: free()\&. 
.br
 
.RE
.PP

.SS "char * ft_gnl (int fd)"

.PP
\fBft_gnl\fP -- Get next line from file descriptor\&. Get next line function is used to read complete lines from a valid file descriptor passed as argument\&. When there are no more lines to read or some error occured, a NULL pointer is returned\&. 
.br
 The typical use of \fBft_gnl()\fP is in a loop to read every line from the file descriptor until the function returns NULL\&.
.PP
\fBParameters\fP
.RS 4
\fIfd\fP - An int value representing the file descriptor to read from\&.
.RE
.PP
\fBReturns\fP
.RS 4
A NUL terminated c-string with the next line read\&. 
.br
 NULL if error or no more lines available\&.
.RE
.PP
\fBWarning\fP
.RS 4
EXTERNAL FUNCTION USED: read(), malloc(), free()\&. 
.br
.RE
.PP
\fBRemarks\fP
.RS 4
Implementation notes: 
.br
 This function can be used to read from multiple file descriptors while maintaning consistence\&. 
.RE
.PP

.SS "void ft_putchar_fd (char c, int fd)"

.PP
\fBft_putchar_fd\fP -- \&.TODO\&. Some_detailed_description\&.TODO\&.
.PP
\fBParameters\fP
.RS 4
\fIc\fP - The character to write\&.
.br
\fIfd\fP - The valid file descriptor to write to\&.
.RE
.PP
\fBWarning\fP
.RS 4
EXTERNAL FUNCTION USED: write()\&. 
.br
 A NULL pointer parameter or a non-terminated string are supposed to make this function crash\&.
.RE
.PP
\fBRemarks\fP
.RS 4
Implementation notes: 
.br
 TODO\&. 
.RE
.PP

.SS "int ft_putchar_fd_safe (char c, int fd)"

.PP
\fBft_putchar_fd_safe\fP -- TODO\&.\&. Some_detailed_description\&.TODO\&.
.PP
\fBParameters\fP
.RS 4
\fIc\fP - The character to write\&.
.br
\fIfd\fP - The valid file descriptor to write to\&.
.RE
.PP
\fBReturns\fP
.RS 4
Number of chars actually printed\&.
.RE
.PP
\fBWarning\fP
.RS 4
EXTERNAL FUNCTION USED: write()\&. 
.br
 TODO\&. A NULL pointer parameter or a non-terminated string are supposed to make this function crash\&.
.RE
.PP
\fBRemarks\fP
.RS 4
Implementation notes: 
.br
 TODO\&. 
.RE
.PP

.SS "void ft_putendl_fd (char * s, int fd)"

.PP
\fBft_putendl_fd\fP -- \&.TODO\&. Some_detailed_description\&.TODO\&.
.PP
\fBParameters\fP
.RS 4
\fIs\fP - The c-string to write\&.
.br
\fIfd\fP - The valid file descriptor to write to\&.
.RE
.PP
\fBWarning\fP
.RS 4
EXTERNAL FUNCTION USED: write()\&. 
.br
 A NULL pointer parameter or a non-terminated string are supposed to make this function crash\&. TODO
.RE
.PP
\fBRemarks\fP
.RS 4
Implementation notes: 
.br
 TODO\&. 
.RE
.PP

.SS "void ft_putnbr_fd (int n, int fd)"

.PP
\fBft_putnbr_fd\fP -- \&.TODO\&. Some_detailed_description\&.TODO\&.
.PP
\fBParameters\fP
.RS 4
\fIn\fP - The integer value to write\&.
.br
\fIfd\fP - The valid file descriptor to write to\&.
.RE
.PP
\fBWarning\fP
.RS 4
EXTERNAL FUNCTION USED: write()\&. 
.br
 A NULL pointer parameter or a non-terminated string are supposed to make this function crash\&.
.RE
.PP
\fBRemarks\fP
.RS 4
Implementation notes: 
.br
 TODO\&. 
.RE
.PP

.SS "void ft_putstr_fd (char * s, int fd)"

.PP
\fBft_putstr_fd\fP -- \&.TODO\&. Some_detailed_description\&.TODO\&.
.PP
\fBParameters\fP
.RS 4
\fIs\fP - The c-string to write\&.
.br
\fIfd\fP - The valid file descriptor to write to\&.
.RE
.PP
\fBWarning\fP
.RS 4
EXTERNAL FUNCTION USED: write()\&. A NULL pointer parameter or a non-terminated string are supposed to make this function crash\&. TODO
.RE
.PP
\fBRemarks\fP
.RS 4
Implementation notes: 
.br
 TODO\&. 
.RE
.PP

.SS "int ft_putstr_fd_safe (char * s, int fd)"

.PP
\fBft_putstr_fd_safe\fP -- TODO\&. Some_detailed_description\&. TODO\&.
.PP
\fBParameters\fP
.RS 4
\fIs\fP - The c-string to write\&.
.br
\fIfd\fP - The valid file descriptor to write to\&.
.RE
.PP
\fBReturns\fP
.RS 4
Number of chars actually printed\&.
.RE
.PP
\fBWarning\fP
.RS 4
EXTERNAL FUNCTION USED: write()\&. 
.br
 TODO\&. 
.br
 A NULL pointer parameter or a non-terminated string are supposed to make this function crash\&.
.RE
.PP
\fBRemarks\fP
.RS 4
Implementation notes: 
.br
 TODO\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Library libft from the source code\&.

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Library libft: include/ft_dlclst.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Library libft<span id="projectnumber">&#160;2024-02-05</span>
   </div>
   <div id="projectbrief">Cummulative util library for Campus 42</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ft_dlclst.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="ft__dlclst_8h__dep__incl.png" border="0" usemap="#ainclude_2ft__dlclst_8hdep" alt=""/></div>
<map name="ainclude_2ft__dlclst_8hdep" id="ainclude_2ft__dlclst_8hdep">
<area shape="rect" title=" " alt="" coords="5,5,141,32"/>
<area shape="rect" href="libft_8h.html" title=" " alt="" coords="18,80,129,107"/>
</map>
</div>
</div>
<p><a href="ft__dlclst_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structs__dlclst.html">s_dlclst</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base for typedef <b>t_dlclst</b> for a doubly linked circular list node.  <a href="structs__dlclst.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a272e4bbf2ff805aeda63d7fc23c5f538"><td class="memItemLeft" align="right" valign="top"><a id="a272e4bbf2ff805aeda63d7fc23c5f538" name="a272e4bbf2ff805aeda63d7fc23c5f538"></a>
typedef struct <a class="el" href="structs__dlclst.html">s_dlclst</a>&#160;</td><td class="memItemRight" valign="bottom"><b>t_dlclst</b></td></tr>
<tr class="separator:a272e4bbf2ff805aeda63d7fc23c5f538"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a014e2d9d05d7c93c7e0ba931c3fba6dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structs__dlclst.html">t_dlclst</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft__dlclst_8h.html#a014e2d9d05d7c93c7e0ba931c3fba6dc">ft_dlclst_new</a> (void *content)</td></tr>
<tr class="memdesc:a014e2d9d05d7c93c7e0ba931c3fba6dc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_dlclst_new</b> &ndash; Creates a list element from pointer to its content.  <a href="ft__dlclst_8h.html#a014e2d9d05d7c93c7e0ba931c3fba6dc">More...</a><br /></td></tr>
<tr class="separator:a014e2d9d05d7c93c7e0ba931c3fba6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd40bb28300bc084c2123bf5a720068f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft__dlclst_8h.html#acd40bb28300bc084c2123bf5a720068f">ft_dlclst_insfront</a> (<a class="el" href="structs__dlclst.html">t_dlclst</a> **lst, <a class="el" href="structs__dlclst.html">t_dlclst</a> *new)</td></tr>
<tr class="memdesc:acd40bb28300bc084c2123bf5a720068f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_dlclst_insfront</b> &ndash; Inserts node at the beginning of the list.  <a href="ft__dlclst_8h.html#acd40bb28300bc084c2123bf5a720068f">More...</a><br /></td></tr>
<tr class="separator:acd40bb28300bc084c2123bf5a720068f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cec00e39def2b7423f167c367039c07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft__dlclst_8h.html#a5cec00e39def2b7423f167c367039c07">ft_dlclst_insback</a> (<a class="el" href="structs__dlclst.html">t_dlclst</a> **lst, <a class="el" href="structs__dlclst.html">t_dlclst</a> *new)</td></tr>
<tr class="memdesc:a5cec00e39def2b7423f167c367039c07"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_dlclst_insback</b> &ndash; Inserts node at the end of the list.  <a href="ft__dlclst_8h.html#a5cec00e39def2b7423f167c367039c07">More...</a><br /></td></tr>
<tr class="separator:a5cec00e39def2b7423f167c367039c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720fd4d25e87e5deebb5145c4589d3bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft__dlclst_8h.html#a720fd4d25e87e5deebb5145c4589d3bd">ft_dlclst_inspos</a> (<a class="el" href="structs__dlclst.html">t_dlclst</a> **lst, <a class="el" href="structs__dlclst.html">t_dlclst</a> *new, unsigned int pos)</td></tr>
<tr class="memdesc:a720fd4d25e87e5deebb5145c4589d3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_dlclst_inspos</b> &ndash; Inserts node at given position.  <a href="ft__dlclst_8h.html#a720fd4d25e87e5deebb5145c4589d3bd">More...</a><br /></td></tr>
<tr class="separator:a720fd4d25e87e5deebb5145c4589d3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37fdd42b9e3f40dff23ede216a6a1a20"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft__dlclst_8h.html#a37fdd42b9e3f40dff23ede216a6a1a20">ft_dlclst_size</a> (<a class="el" href="structs__dlclst.html">t_dlclst</a> *lst)</td></tr>
<tr class="memdesc:a37fdd42b9e3f40dff23ede216a6a1a20"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_dlclst_size</b> &ndash; Counts the number of nodes in a list.  <a href="ft__dlclst_8h.html#a37fdd42b9e3f40dff23ede216a6a1a20">More...</a><br /></td></tr>
<tr class="separator:a37fdd42b9e3f40dff23ede216a6a1a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399b587bbd316eb92f4f34571ca82c46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structs__dlclst.html">t_dlclst</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft__dlclst_8h.html#a399b587bbd316eb92f4f34571ca82c46">ft_dlclst_last</a> (<a class="el" href="structs__dlclst.html">t_dlclst</a> *lst)</td></tr>
<tr class="memdesc:a399b587bbd316eb92f4f34571ca82c46"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_dlclst_last</b> &ndash; Returns the last node of the list.  <a href="ft__dlclst_8h.html#a399b587bbd316eb92f4f34571ca82c46">More...</a><br /></td></tr>
<tr class="separator:a399b587bbd316eb92f4f34571ca82c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3818fab59a43f45768d1b125a825d55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft__dlclst_8h.html#ab3818fab59a43f45768d1b125a825d55">ft_dlclst_remfront</a> (<a class="el" href="structs__dlclst.html">t_dlclst</a> **lst, void(*del)(void *))</td></tr>
<tr class="memdesc:ab3818fab59a43f45768d1b125a825d55"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_dlclst_remfront</b> &ndash; Removes the first node of the list and frees memory of the list item and its content.  <a href="ft__dlclst_8h.html#ab3818fab59a43f45768d1b125a825d55">More...</a><br /></td></tr>
<tr class="separator:ab3818fab59a43f45768d1b125a825d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e2cb5ea206ea743316838b29e55069"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft__dlclst_8h.html#a18e2cb5ea206ea743316838b29e55069">ft_dlclst_remback</a> (<a class="el" href="structs__dlclst.html">t_dlclst</a> **lst, void(*del)(void *))</td></tr>
<tr class="memdesc:a18e2cb5ea206ea743316838b29e55069"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_dlclst_remback</b> &ndash; Removes the last node of the list and frees memory of the list item and its content.  <a href="ft__dlclst_8h.html#a18e2cb5ea206ea743316838b29e55069">More...</a><br /></td></tr>
<tr class="separator:a18e2cb5ea206ea743316838b29e55069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3835d68bd79a37652ee4748a2f51f66e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft__dlclst_8h.html#a3835d68bd79a37652ee4748a2f51f66e">ft_dlclst_rempos</a> (<a class="el" href="structs__dlclst.html">t_dlclst</a> **l, void(*d)(void *), int unsigned pos)</td></tr>
<tr class="memdesc:a3835d68bd79a37652ee4748a2f51f66e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_dlclst_rempos</b> &ndash; Removes the node of the list at given position and frees memory of the list item and its content.  <a href="ft__dlclst_8h.html#a3835d68bd79a37652ee4748a2f51f66e">More...</a><br /></td></tr>
<tr class="separator:a3835d68bd79a37652ee4748a2f51f66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768b997e9933b49a408ce2da5015a6d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft__dlclst_8h.html#a768b997e9933b49a408ce2da5015a6d3">ft_dlclst_clear</a> (<a class="el" href="structs__dlclst.html">t_dlclst</a> **lst, void(*del)(void *))</td></tr>
<tr class="memdesc:a768b997e9933b49a408ce2da5015a6d3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_dlclst_clear</b> &ndash; Deletes and frees given node and succesors. (freeing contents).  <a href="ft__dlclst_8h.html#a768b997e9933b49a408ce2da5015a6d3">More...</a><br /></td></tr>
<tr class="separator:a768b997e9933b49a408ce2da5015a6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a44b3e6765a687755bb8069aa135da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft__dlclst_8h.html#ad9a44b3e6765a687755bb8069aa135da">ft_dlclst_iter</a> (<a class="el" href="structs__dlclst.html">t_dlclst</a> *lst, void(*f)(void *))</td></tr>
<tr class="memdesc:ad9a44b3e6765a687755bb8069aa135da"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_dlclst_iter</b> &ndash; Applies provided function f to the content of each node on list.  <a href="ft__dlclst_8h.html#ad9a44b3e6765a687755bb8069aa135da">More...</a><br /></td></tr>
<tr class="separator:ad9a44b3e6765a687755bb8069aa135da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a66edceeb972c4fd6b00c92f3d11cb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structs__dlclst.html">t_dlclst</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft__dlclst_8h.html#a7a66edceeb972c4fd6b00c92f3d11cb6">ft_dlclst_map</a> (<a class="el" href="structs__dlclst.html">t_dlclst</a> *l, void *(*f)(void *), void(*d)(void *))</td></tr>
<tr class="memdesc:a7a66edceeb972c4fd6b00c92f3d11cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_dlclst_map</b> &ndash; Returns new list based on applying f to each nodes content.  <a href="ft__dlclst_8h.html#a7a66edceeb972c4fd6b00c92f3d11cb6">More...</a><br /></td></tr>
<tr class="separator:a7a66edceeb972c4fd6b00c92f3d11cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69898415ba83766723aba5d79f24bcc3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft__dlclst_8h.html#a69898415ba83766723aba5d79f24bcc3">ft_dlclst_search</a> (<a class="el" href="structs__dlclst.html">t_dlclst</a> *l, int(*cmp)(void *, void *), void *co)</td></tr>
<tr class="memdesc:a69898415ba83766723aba5d79f24bcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_dlclst_search</b> &ndash; Search content inside the list.  <a href="ft__dlclst_8h.html#a69898415ba83766723aba5d79f24bcc3">More...</a><br /></td></tr>
<tr class="separator:a69898415ba83766723aba5d79f24bcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4856a66a03fa2cf41649789a01c550ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft__dlclst_8h.html#a4856a66a03fa2cf41649789a01c550ed">ft_dlclst_rotatenext</a> (<a class="el" href="structs__dlclst.html">t_dlclst</a> **lst, unsigned int n)</td></tr>
<tr class="memdesc:a4856a66a03fa2cf41649789a01c550ed"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_dlclst_rotatenext</b> &ndash; Shifts the head of the list in the 'next' direction.  <a href="ft__dlclst_8h.html#a4856a66a03fa2cf41649789a01c550ed">More...</a><br /></td></tr>
<tr class="separator:a4856a66a03fa2cf41649789a01c550ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce570469a04365bce04c934daacbd85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft__dlclst_8h.html#a8ce570469a04365bce04c934daacbd85">ft_dlclst_rotateprev</a> (<a class="el" href="structs__dlclst.html">t_dlclst</a> **lst, unsigned int n)</td></tr>
<tr class="memdesc:a8ce570469a04365bce04c934daacbd85"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_dlclst_rotateprev</b> &ndash; Shifts the head of the list in the 'prev' direction.  <a href="ft__dlclst_8h.html#a8ce570469a04365bce04c934daacbd85">More...</a><br /></td></tr>
<tr class="separator:a8ce570469a04365bce04c934daacbd85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc544a59026ac7ffb74d409fd9603fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft__dlclst_8h.html#acdc544a59026ac7ffb74d409fd9603fb">ft_dlclst_swapfront</a> (<a class="el" href="structs__dlclst.html">t_dlclst</a> **lst)</td></tr>
<tr class="memdesc:acdc544a59026ac7ffb74d409fd9603fb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_dlclst_swapfront</b> &ndash; Swaps the first and second elements of the list.  <a href="ft__dlclst_8h.html#acdc544a59026ac7ffb74d409fd9603fb">More...</a><br /></td></tr>
<tr class="separator:acdc544a59026ac7ffb74d409fd9603fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e6234d90a04c3bc3a6aa6165ea2ef0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft__dlclst_8h.html#a63e6234d90a04c3bc3a6aa6165ea2ef0">ft_dlclst_swapback</a> (<a class="el" href="structs__dlclst.html">t_dlclst</a> **lst)</td></tr>
<tr class="memdesc:a63e6234d90a04c3bc3a6aa6165ea2ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_dlclst_swapback</b> &ndash; Swaps the last and next to last elements of the list.  <a href="ft__dlclst_8h.html#a63e6234d90a04c3bc3a6aa6165ea2ef0">More...</a><br /></td></tr>
<tr class="separator:a63e6234d90a04c3bc3a6aa6165ea2ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67e079410375b12b27ad1cb5fef5722"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structs__dlclst.html">t_dlclst</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft__dlclst_8h.html#ae67e079410375b12b27ad1cb5fef5722">ft_dlclst_extractfront</a> (<a class="el" href="structs__dlclst.html">t_dlclst</a> **lst)</td></tr>
<tr class="memdesc:ae67e079410375b12b27ad1cb5fef5722"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_dlclst_extractfront</b> &ndash; Removes the first node of the list and returns it.  <a href="ft__dlclst_8h.html#ae67e079410375b12b27ad1cb5fef5722">More...</a><br /></td></tr>
<tr class="separator:ae67e079410375b12b27ad1cb5fef5722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d4f40c769d4e194ed80aa57567424e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structs__dlclst.html">t_dlclst</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft__dlclst_8h.html#a28d4f40c769d4e194ed80aa57567424e">ft_dlclst_extractback</a> (<a class="el" href="structs__dlclst.html">t_dlclst</a> **lst)</td></tr>
<tr class="memdesc:a28d4f40c769d4e194ed80aa57567424e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_dlclst_extractback</b> &ndash; Removes the last node of the list and returns it.  <a href="ft__dlclst_8h.html#a28d4f40c769d4e194ed80aa57567424e">More...</a><br /></td></tr>
<tr class="separator:a28d4f40c769d4e194ed80aa57567424e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60710bfd0f35b94e824ba1fd3da63485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structs__dlclst.html">t_dlclst</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft__dlclst_8h.html#a60710bfd0f35b94e824ba1fd3da63485">ft_dlclst_extractpos</a> (<a class="el" href="structs__dlclst.html">t_dlclst</a> **lst, unsigned int pos)</td></tr>
<tr class="memdesc:a60710bfd0f35b94e824ba1fd3da63485"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_dlclst_extractpos</b> &ndash; Removes the node of the list at given position and returns it.  <a href="ft__dlclst_8h.html#a60710bfd0f35b94e824ba1fd3da63485">More...</a><br /></td></tr>
<tr class="separator:a60710bfd0f35b94e824ba1fd3da63485"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Doubly linked circular list implementation. Part of libft library. <br  />
 A dlclst has a head which points to the node that is to be interpreted as the begining of the list or its first element. In the same way, the list alsohas a last element which will be the node pointed to by the 'prev' field of the head node. <br  />
 In a dlclst list with just one element, that element will point to itself. That is, the only node will be the first and the last at the same time. <br  />
 In this sense, due to the circular nature of the dlclst list, NO check is performed against the size of the list while operating on their elements and traversing the list. A value for position or steps from one node to another that could cause an overflow of the head of the list is allowed and will be interpreted consistently with the circular nature of the list. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a768b997e9933b49a408ce2da5015a6d3" name="a768b997e9933b49a408ce2da5015a6d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a768b997e9933b49a408ce2da5015a6d3">&#9670;&nbsp;</a></span>ft_dlclst_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ft_dlclst_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structs__dlclst.html">t_dlclst</a> **&#160;</td>
          <td class="paramname"><em>lst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>del</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_dlclst_clear</b> &ndash; Deletes and frees given node and succesors. (freeing contents). </p>
<p >Deletes and frees the given node and every successor of that node, using the function ’del’ and free(). <br  />
 Finally, the pointer to the node is set to NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lst-</td><td>The address of a pointer to a node. If NULL, nothing is done. Is set to NULL by this function.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">del</td><td>- The address of the function that shall be used to properly free only the content of the node. This function must be capable of handling a NULL content pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: free(). <br  />
 </dd></dl>

</div>
</div>
<a id="a28d4f40c769d4e194ed80aa57567424e" name="a28d4f40c769d4e194ed80aa57567424e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d4f40c769d4e194ed80aa57567424e">&#9670;&nbsp;</a></span>ft_dlclst_extractback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structs__dlclst.html">t_dlclst</a> * ft_dlclst_extractback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structs__dlclst.html">t_dlclst</a> **&#160;</td>
          <td class="paramname"><em>lst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_dlclst_extractback</b> &ndash; Removes the last node of the list and returns it. </p>
<p >Takes as a parameter the address of the pointer to the first node of the list, removes it from the list and returns it. The pointers of the <br  />
 remaining nodes of the list are updated in order to maintain the consistency of the circular list. <br  />
 The pointer to lst might be updated to represent the new first element of the list. It will be NULL if the removed node was the only element in the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lst</td><td>- The address of the pointer to the first node of the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted node. </dd></dl>

</div>
</div>
<a id="ae67e079410375b12b27ad1cb5fef5722" name="ae67e079410375b12b27ad1cb5fef5722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67e079410375b12b27ad1cb5fef5722">&#9670;&nbsp;</a></span>ft_dlclst_extractfront()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structs__dlclst.html">t_dlclst</a> * ft_dlclst_extractfront </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structs__dlclst.html">t_dlclst</a> **&#160;</td>
          <td class="paramname"><em>lst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_dlclst_extractfront</b> &ndash; Removes the first node of the list and returns it. </p>
<p >Takes as a parameter the address of the pointer to the first node of the list, removes it from the list and returns it. The pointers of the remaining nodes of the list are updated in orderr to maintain the consistency of the circular list. <br  />
 The pointer to lst is updated to represent the new first element of the list. It will be NULL if the removed node was the only element in the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lst</td><td>- The address of the pointer to the first node of the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted node. </dd></dl>

</div>
</div>
<a id="a60710bfd0f35b94e824ba1fd3da63485" name="a60710bfd0f35b94e824ba1fd3da63485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60710bfd0f35b94e824ba1fd3da63485">&#9670;&nbsp;</a></span>ft_dlclst_extractpos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structs__dlclst.html">t_dlclst</a> * ft_dlclst_extractpos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structs__dlclst.html">t_dlclst</a> **&#160;</td>
          <td class="paramname"><em>lst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_dlclst_extractpos</b> &ndash; Removes the node of the list at given position and returns it. </p>
<p >Takes as a parameter the address of the pointer to the first node of the list, removes the node that occupies the given position from the list and returns it. The pointers of the remaining nodes of the list are updated in order to maintain the consistency of the circular list. <br  />
 The pointer to lst might be updated to represent the new first element of the list. It will be NULL if the removed node was the only element in the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lst</td><td>- The address of the pointer to the first node of the list.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>- Positive value representing the position in the list of the node to be extracted (always in the next direction, first node has a position of 0). <br  />
 A zero value produces the same result as <a class="el" href="ft__dlclst_8h.html#ae67e079410375b12b27ad1cb5fef5722" title="ft_dlclst_extractfront – Removes the first node of the list and returns it.">ft_dlclst_extractfront()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted node. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>NO check is performed for element position as relative to the size of the list. A value for position or steps that could cause an overflow of the head of the list is allowed and will be interpreted consistently with the circular nature of the list. </dd></dl>

</div>
</div>
<a id="a5cec00e39def2b7423f167c367039c07" name="a5cec00e39def2b7423f167c367039c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cec00e39def2b7423f167c367039c07">&#9670;&nbsp;</a></span>ft_dlclst_insback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ft_dlclst_insback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structs__dlclst.html">t_dlclst</a> **&#160;</td>
          <td class="paramname"><em>lst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structs__dlclst.html">t_dlclst</a> *&#160;</td>
          <td class="paramname"><em>new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_dlclst_insback</b> &ndash; Inserts node at the end of the list. </p>
<p >Inserts the node ’new’ at the end of the list. If *lst == NULL the new node becomes the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lst</td><td>- The address of a pointer to the first node of a list.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new</td><td>- A pointer to the node to be added to the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>NO check is performed for NULL pointers passed as arguments. In such cases, CRASHING is guaranteed.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 Don't check for valid pointers. </dd></dl>

</div>
</div>
<a id="acd40bb28300bc084c2123bf5a720068f" name="acd40bb28300bc084c2123bf5a720068f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd40bb28300bc084c2123bf5a720068f">&#9670;&nbsp;</a></span>ft_dlclst_insfront()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ft_dlclst_insfront </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structs__dlclst.html">t_dlclst</a> **&#160;</td>
          <td class="paramname"><em>lst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structs__dlclst.html">t_dlclst</a> *&#160;</td>
          <td class="paramname"><em>new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_dlclst_insfront</b> &ndash; Inserts node at the beginning of the list. </p>
<p >Inserts the node ’new’ at the beginning of the list. If *lst == NULL the new node becomes the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lst</td><td>- The address of a pointer to the first node of a list.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new</td><td>- A pointer to the node to be added to the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>NO check is performed for NULL pointers passed as arguments. In such cases, CRASHING is guaranteed.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 Don't check for valid pointers. </dd></dl>

</div>
</div>
<a id="a720fd4d25e87e5deebb5145c4589d3bd" name="a720fd4d25e87e5deebb5145c4589d3bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a720fd4d25e87e5deebb5145c4589d3bd">&#9670;&nbsp;</a></span>ft_dlclst_inspos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ft_dlclst_inspos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structs__dlclst.html">t_dlclst</a> **&#160;</td>
          <td class="paramname"><em>lst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structs__dlclst.html">t_dlclst</a> *&#160;</td>
          <td class="paramname"><em>new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_dlclst_inspos</b> &ndash; Inserts node at given position. </p>
<p >Inserts the node ’new’ at given position. If *lst == NULL the new node becomes the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lst</td><td>- The address of a pointer to the first node of a list.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new</td><td>- A pointer to the node to be added to the list.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>- Positive value representing the position the new node will have inside the list (always in the next direction, first node has 0 pos). <br  />
 A zero value produces the same result as ft_dlclst_insertfront(). <br  />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>NO check is performed for NULL pointers passed as arguments. In such cases, CRASHING is guaranteed. <br  />
 NO check is performed for element position as relative to the size of the list. A value for position or steps that could cause an overflow of the head of the list is allowed and will be interpreted consistently with the circular nature of the list.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 Don't check for valid pointers. </dd></dl>

</div>
</div>
<a id="ad9a44b3e6765a687755bb8069aa135da" name="ad9a44b3e6765a687755bb8069aa135da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a44b3e6765a687755bb8069aa135da">&#9670;&nbsp;</a></span>ft_dlclst_iter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ft_dlclst_iter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structs__dlclst.html">t_dlclst</a> *&#160;</td>
          <td class="paramname"><em>lst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_dlclst_iter</b> &ndash; Applies provided function f to the content of each node on list. </p>
<p >Iterates the list ’lst’ and applies the function ’f’ on the content of each node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lst</td><td>- The address of a pointer to a node. If NULL nothing is done.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>- The address of the function that shall be used apply on every node's content while traversing the whole list. This function must be capable of handling a NULL content pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>NO check is performed for NULL pointers passed as arguments. In such cases, CRASHING is guaranteed. </dd></dl>

</div>
</div>
<a id="a399b587bbd316eb92f4f34571ca82c46" name="a399b587bbd316eb92f4f34571ca82c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399b587bbd316eb92f4f34571ca82c46">&#9670;&nbsp;</a></span>ft_dlclst_last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structs__dlclst.html">t_dlclst</a> * ft_dlclst_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structs__dlclst.html">t_dlclst</a> *&#160;</td>
          <td class="paramname"><em>lst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_dlclst_last</b> &ndash; Returns the last node of the list. </p>
<p >Returns the last node of the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lst</td><td>- A pointer to the first node of the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the last node of the list. <br  />
 Returns NULL if lst == NULL. </dd></dl>

</div>
</div>
<a id="a7a66edceeb972c4fd6b00c92f3d11cb6" name="a7a66edceeb972c4fd6b00c92f3d11cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a66edceeb972c4fd6b00c92f3d11cb6">&#9670;&nbsp;</a></span>ft_dlclst_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structs__dlclst.html">t_dlclst</a> * ft_dlclst_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structs__dlclst.html">t_dlclst</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_dlclst_map</b> &ndash; Returns new list based on applying f to each nodes content. </p>
<p >Iterates the list ’lst’ and applies the function ’f’ on the content of each node. Creates a new list resulting of the successive applications of the function ’f’. The ’del’ function is used to delete the content of a node if needed. If at some point the funcion fails, the in-construction new list must is cleared completely and NULL pointer is returned. If an error occurs while creating the new list, every memory is freed and a NULL is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>- The address of a pointer to a node. If NULL nothing is done and a NULL pointer is returned.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>- The address of the function that shall be applied on every node's content while traversing the original list to return a pointer to the new content for every node of the new list. This function must be capable of handling a NULL content pointer. This function must allocate memory for the generated new contents. This function must return NULL if error.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>- The address of the function that shall be used to properly free only the content of the node. This function must be capable of handling a NULL content pointer. This function is used if an error occurs while creating the new list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new list. <br  />
 NULL if error occurs.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: malloc(), free(). <br  />
 </dd></dl>

</div>
</div>
<a id="a014e2d9d05d7c93c7e0ba931c3fba6dc" name="a014e2d9d05d7c93c7e0ba931c3fba6dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014e2d9d05d7c93c7e0ba931c3fba6dc">&#9670;&nbsp;</a></span>ft_dlclst_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structs__dlclst.html">t_dlclst</a> * ft_dlclst_new </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>content</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_dlclst_new</b> &ndash; Creates a list element from pointer to its content. </p>
<p >Allocates (with malloc()) and returns a new node. <br  />
 The member variable ’content’ is initialized with the value of the parameter ’content’. The variables 'next' and 'prev' are initialized to NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">content</td><td>- The pointer to the content to create the node with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new node. <br  />
 Returns NULL if malloc() fails.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: malloc(). <br  />
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 Argument content is NOT checked for NULL, a node with NULL content is returned. <br  />
 If malloc fails, must return NULL. </dd></dl>

</div>
</div>
<a id="a18e2cb5ea206ea743316838b29e55069" name="a18e2cb5ea206ea743316838b29e55069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e2cb5ea206ea743316838b29e55069">&#9670;&nbsp;</a></span>ft_dlclst_remback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ft_dlclst_remback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structs__dlclst.html">t_dlclst</a> **&#160;</td>
          <td class="paramname"><em>lst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>del</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_dlclst_remback</b> &ndash; Removes the last node of the list and frees memory of the list item and its content. </p>
<p >Takes as a parameter the address of the pointer to the first node of the list and frees the memory of the last node content using the ’del’ function provided by the caller. Then frees the node memory. <br  />
 The memory of 'next' and 'prev' nodes of the deleted first node are not freed. The pointers of those nodes are updated in order to maintain the consistency of the circular list. <br  />
 The pointer to lst might be updated to represent the new first element of the list. It will be NULL if the removed node was the only element in the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lst</td><td>- The address of the pointer to the first node of the list.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">del</td><td>- The address of the function that shall be used to properly free only the content of the node. This function must be capable of handling a NULL content pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: free(). <br  />
 </dd></dl>

</div>
</div>
<a id="ab3818fab59a43f45768d1b125a825d55" name="ab3818fab59a43f45768d1b125a825d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3818fab59a43f45768d1b125a825d55">&#9670;&nbsp;</a></span>ft_dlclst_remfront()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ft_dlclst_remfront </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structs__dlclst.html">t_dlclst</a> **&#160;</td>
          <td class="paramname"><em>lst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>del</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_dlclst_remfront</b> &ndash; Removes the first node of the list and frees memory of the list item and its content. </p>
<p >Takes as a parameter the address of the pointer to the first node of the list and frees the memory of the first node content using the ’del’ function provided by the caller. Then frees the node memory. <br  />
 The memory of 'next' and 'prev' nodes of the deleted first node are not freed. The pointers of those nodes are updated in order to maintain the consistency of the circular list. <br  />
 The pointer to lst is updated to represent the new first element of the list. It will be NULL if the removed node was the only element in the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lst</td><td>- The address of the pointer to the first node of the list.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">del</td><td>- The address of the function that shall be used to properly free only the content of the node. This function must be capable of handling a NULL content pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: free(). <br  />
 </dd></dl>

</div>
</div>
<a id="a3835d68bd79a37652ee4748a2f51f66e" name="a3835d68bd79a37652ee4748a2f51f66e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3835d68bd79a37652ee4748a2f51f66e">&#9670;&nbsp;</a></span>ft_dlclst_rempos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ft_dlclst_rempos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structs__dlclst.html">t_dlclst</a> **&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int unsigned&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_dlclst_rempos</b> &ndash; Removes the node of the list at given position and frees memory of the list item and its content. </p>
<p >Takes as a parameter the address of the pointer to the first node of the list and frees the memory of the referred node content using the ’del’ function provided by the caller. Then frees the node memory. <br  />
 The memory of 'next' and 'prev' nodes of the deleted first node are not freed. The pointers of those nodes are updated in order to maintain the consistency of the circular list. <br  />
 The pointer to lst might be updated to represent the new first element of the list. It will be NULL if the removed node was the only element in the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">l</td><td>- The address of the pointer to the first node of the list.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>- The address of the function that shall be used to properly free only the content of the node. This function must be capable of handling a NULL content pointer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>- Positive value representing the position in the list of the node to be removed (always in the next direction, first node has 0 pos). <br  />
 A zero value produces the same result as <a class="el" href="ft__dlclst_8h.html#ab3818fab59a43f45768d1b125a825d55" title="ft_dlclst_remfront – Removes the first node of the list and frees memory of the list item and its con...">ft_dlclst_remfront()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: free(). <br  />
 NO check is performed for element position as relative to the size of the list. A value for position or steps that could cause an overflow of the head of the list is allowed and will be interpreted consistently with the circular nature of the list. </dd></dl>

</div>
</div>
<a id="a4856a66a03fa2cf41649789a01c550ed" name="a4856a66a03fa2cf41649789a01c550ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4856a66a03fa2cf41649789a01c550ed">&#9670;&nbsp;</a></span>ft_dlclst_rotatenext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ft_dlclst_rotatenext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structs__dlclst.html">t_dlclst</a> **&#160;</td>
          <td class="paramname"><em>lst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_dlclst_rotatenext</b> &ndash; Shifts the head of the list in the 'next' direction. </p>
<p >Moves the pointer that points to the head/front of the list 'n' steps in the 'next' direction, thus making the element in the n-th position the new head/front of the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lst</td><td>- The address of a pointer to the first node of a list.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>- The steps to move the head of the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>NO check is performed for element position as relative to the size of the list. A value for position or steps that could cause an overflow of the head of the list is allowed and will be interpreted consistently with the circular nature of the list. </dd></dl>

</div>
</div>
<a id="a8ce570469a04365bce04c934daacbd85" name="a8ce570469a04365bce04c934daacbd85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce570469a04365bce04c934daacbd85">&#9670;&nbsp;</a></span>ft_dlclst_rotateprev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ft_dlclst_rotateprev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structs__dlclst.html">t_dlclst</a> **&#160;</td>
          <td class="paramname"><em>lst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_dlclst_rotateprev</b> &ndash; Shifts the head of the list in the 'prev' direction. </p>
<p >Moves the pointer that points to the head/front of the list 'n' steps in the 'prev' direction, thus making the element in the (size -n)-th position the new head/front of the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lst</td><td>- The address of a pointer to the first node of a list.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>- The steps to move the head of the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>NO check is performed for element position as relative to the size of the list. A value for position or steps that could cause an overflow of the head of the list is allowed and will be interpreted consistently with the circular nature of the list. </dd></dl>

</div>
</div>
<a id="a69898415ba83766723aba5d79f24bcc3" name="a69898415ba83766723aba5d79f24bcc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69898415ba83766723aba5d79f24bcc3">&#9670;&nbsp;</a></span>ft_dlclst_search()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ft_dlclst_search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structs__dlclst.html">t_dlclst</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *, void *)&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>co</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_dlclst_search</b> &ndash; Search content inside the list. </p>
<p >Iterates the list ’lst’ and applies the function ’cmp’ to compare the content of each node with the content passed as argument. The first time a match is detected (in the next direction), the position of the element is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>- The pointer to a list. If NULL, -1 is returned.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmp</td><td>- The address of the function that shall be applied on every node's content while traversing the original list to compare it against the content 'co'. This function returns a non-zero value if there is a match. This function must be capable of handling a NULL content pointer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">co</td><td>- The address of a content to be compared against each node's content.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of the first node (in the next direction) which content matches the content passed as an argument. <br  />
 A -1 is returned if there is no match. </dd></dl>

</div>
</div>
<a id="a37fdd42b9e3f40dff23ede216a6a1a20" name="a37fdd42b9e3f40dff23ede216a6a1a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37fdd42b9e3f40dff23ede216a6a1a20">&#9670;&nbsp;</a></span>ft_dlclst_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ft_dlclst_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structs__dlclst.html">t_dlclst</a> *&#160;</td>
          <td class="paramname"><em>lst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_dlclst_size</b> &ndash; Counts the number of nodes in a list. </p>
<p >Counts the number of nodes in a list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lst</td><td>- A pointer to the first element of the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the list. <br  />
 If lst == NULL a 0 value is returned. </dd></dl>

</div>
</div>
<a id="a63e6234d90a04c3bc3a6aa6165ea2ef0" name="a63e6234d90a04c3bc3a6aa6165ea2ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e6234d90a04c3bc3a6aa6165ea2ef0">&#9670;&nbsp;</a></span>ft_dlclst_swapback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ft_dlclst_swapback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structs__dlclst.html">t_dlclst</a> **&#160;</td>
          <td class="paramname"><em>lst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_dlclst_swapback</b> &ndash; Swaps the last and next to last elements of the list. </p>
<p >Swaps the last and next to last elements of the list. The head of the list may change accordingly (i.e. in a list with just two elements).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lst</td><td>- The address of a pointer to the first node of a list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdc544a59026ac7ffb74d409fd9603fb" name="acdc544a59026ac7ffb74d409fd9603fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc544a59026ac7ffb74d409fd9603fb">&#9670;&nbsp;</a></span>ft_dlclst_swapfront()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ft_dlclst_swapfront </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structs__dlclst.html">t_dlclst</a> **&#160;</td>
          <td class="paramname"><em>lst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_dlclst_swapfront</b> &ndash; Swaps the first and second elements of the list. </p>
<p >Swaps the first and second elements of the list. The head of the list changes accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lst</td><td>- The address of a pointer to the first node of a list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: libft.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">libft.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for libft.h:</div>
<div class="dyncontent">
<div class="center"><img src="libft_8h__incl.png" border="0" usemap="#alibft_8h" alt=""/></div>
</div>
</div>
<p><a href="libft_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structs__list.html">s_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>t_list</b> &ndash; Typedef struct for a dynamic list node  <a href="structs__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aefde00352c5326bb1c28ebd4404c4795"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structs__list.html">s_list</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#aefde00352c5326bb1c28ebd4404c4795">t_list</a></td></tr>
<tr class="memdesc:aefde00352c5326bb1c28ebd4404c4795"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>t_list</b> &ndash; Typedef struct for a dynamic list node  <a href="libft_8h.html#aefde00352c5326bb1c28ebd4404c4795">More...</a><br /></td></tr>
<tr class="separator:aefde00352c5326bb1c28ebd4404c4795"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1ad9c4559cffbb211ec56fe8964f30f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a1ad9c4559cffbb211ec56fe8964f30f9">ft_isupper</a> (int c)</td></tr>
<tr class="memdesc:a1ad9c4559cffbb211ec56fe8964f30f9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_isupper</b> &ndash; Tests for uppercase alphabetic character.  <a href="libft_8h.html#a1ad9c4559cffbb211ec56fe8964f30f9">More...</a><br /></td></tr>
<tr class="separator:a1ad9c4559cffbb211ec56fe8964f30f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2643d7f2fbcb6d5567a22d8f19e0ad70"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a2643d7f2fbcb6d5567a22d8f19e0ad70">ft_islower</a> (int c)</td></tr>
<tr class="memdesc:a2643d7f2fbcb6d5567a22d8f19e0ad70"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_islower</b> &ndash; Tests for lowercase alphabetic character.  <a href="libft_8h.html#a2643d7f2fbcb6d5567a22d8f19e0ad70">More...</a><br /></td></tr>
<tr class="separator:a2643d7f2fbcb6d5567a22d8f19e0ad70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac283963beaa3b8c7d09b78851cda297e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#ac283963beaa3b8c7d09b78851cda297e">ft_isalpha</a> (int c)</td></tr>
<tr class="memdesc:ac283963beaa3b8c7d09b78851cda297e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_isalpha</b> &ndash; Checks for an alphabetic character.  <a href="libft_8h.html#ac283963beaa3b8c7d09b78851cda297e">More...</a><br /></td></tr>
<tr class="separator:ac283963beaa3b8c7d09b78851cda297e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf15b8a1a277d1e2ce3654101a2003d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a2cf15b8a1a277d1e2ce3654101a2003d">ft_isdigit</a> (int c)</td></tr>
<tr class="memdesc:a2cf15b8a1a277d1e2ce3654101a2003d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_isdigit</b> &ndash; Checks for a digit character.  <a href="libft_8h.html#a2cf15b8a1a277d1e2ce3654101a2003d">More...</a><br /></td></tr>
<tr class="separator:a2cf15b8a1a277d1e2ce3654101a2003d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9bd1a8fd96208017945d589974efc65"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#ac9bd1a8fd96208017945d589974efc65">ft_issign</a> (char c)</td></tr>
<tr class="memdesc:ac9bd1a8fd96208017945d589974efc65"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_issign</b> &ndash; Checks for a '+' '-' character.  <a href="libft_8h.html#ac9bd1a8fd96208017945d589974efc65">More...</a><br /></td></tr>
<tr class="separator:ac9bd1a8fd96208017945d589974efc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2c3821ea43ebdf97de07b123503f8b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a9c2c3821ea43ebdf97de07b123503f8b">ft_isalnum</a> (int c)</td></tr>
<tr class="memdesc:a9c2c3821ea43ebdf97de07b123503f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_isalnum</b> &ndash; Checks for an alphanumeric character.  <a href="libft_8h.html#a9c2c3821ea43ebdf97de07b123503f8b">More...</a><br /></td></tr>
<tr class="separator:a9c2c3821ea43ebdf97de07b123503f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf60ddbec6479540e81f3648cf71f1f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#abf60ddbec6479540e81f3648cf71f1f4">ft_isascii</a> (int c)</td></tr>
<tr class="memdesc:abf60ddbec6479540e81f3648cf71f1f4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_isascii</b> &ndash; Checks for (basic) ASCII character.  <a href="libft_8h.html#abf60ddbec6479540e81f3648cf71f1f4">More...</a><br /></td></tr>
<tr class="separator:abf60ddbec6479540e81f3648cf71f1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcdba69692f21146aeea5b3d59b7d0ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#abcdba69692f21146aeea5b3d59b7d0ca">ft_isprint</a> (int c)</td></tr>
<tr class="memdesc:abcdba69692f21146aeea5b3d59b7d0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_isprint</b> &ndash; Checks for printable (basic) ASCII character.  <a href="libft_8h.html#abcdba69692f21146aeea5b3d59b7d0ca">More...</a><br /></td></tr>
<tr class="separator:abcdba69692f21146aeea5b3d59b7d0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cd21d0fd288012f02809cba504f650"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a76cd21d0fd288012f02809cba504f650">ft_isspace</a> (int c)</td></tr>
<tr class="memdesc:a76cd21d0fd288012f02809cba504f650"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_isspace</b> &ndash; White-space (in the broad sense) character test.  <a href="libft_8h.html#a76cd21d0fd288012f02809cba504f650">More...</a><br /></td></tr>
<tr class="separator:a76cd21d0fd288012f02809cba504f650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef116be7b5bceafff4b59f20a4433d12"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#aef116be7b5bceafff4b59f20a4433d12">ft_toupper</a> (int c)</td></tr>
<tr class="memdesc:aef116be7b5bceafff4b59f20a4433d12"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_toupper</b> &ndash; If lowercase, changes to uppercase.  <a href="libft_8h.html#aef116be7b5bceafff4b59f20a4433d12">More...</a><br /></td></tr>
<tr class="separator:aef116be7b5bceafff4b59f20a4433d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86e5297914753b6c82d7e3c3020ce17"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#ab86e5297914753b6c82d7e3c3020ce17">ft_tolower</a> (int c)</td></tr>
<tr class="memdesc:ab86e5297914753b6c82d7e3c3020ce17"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_tolower</b> &ndash; If uppercase, changes to lowercase.  <a href="libft_8h.html#ab86e5297914753b6c82d7e3c3020ce17">More...</a><br /></td></tr>
<tr class="separator:ab86e5297914753b6c82d7e3c3020ce17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d0a16cec67fe4c1af22f1571f4f8a6"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a19d0a16cec67fe4c1af22f1571f4f8a6">ft_memset</a> (void *b, int c, size_t len)</td></tr>
<tr class="memdesc:a19d0a16cec67fe4c1af22f1571f4f8a6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_memset</b> &ndash; Fills memory with a constant byte.  <a href="libft_8h.html#a19d0a16cec67fe4c1af22f1571f4f8a6">More...</a><br /></td></tr>
<tr class="separator:a19d0a16cec67fe4c1af22f1571f4f8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5937ab0d08e31d0e3e4a16ec71e293a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a5937ab0d08e31d0e3e4a16ec71e293a1">ft_bzero</a> (void *s, size_t n)</td></tr>
<tr class="memdesc:a5937ab0d08e31d0e3e4a16ec71e293a1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_bzero</b> &ndash; Fills memory with zeros.  <a href="libft_8h.html#a5937ab0d08e31d0e3e4a16ec71e293a1">More...</a><br /></td></tr>
<tr class="separator:a5937ab0d08e31d0e3e4a16ec71e293a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5c5d19b1f0355d9768c75d30ed5559"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a5f5c5d19b1f0355d9768c75d30ed5559">ft_memcpy</a> (void *dst, const void *src, size_t n)</td></tr>
<tr class="memdesc:a5f5c5d19b1f0355d9768c75d30ed5559"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_memcpy</b> &ndash; Copies memory area (<b>overlapping unsafe</b>).  <a href="libft_8h.html#a5f5c5d19b1f0355d9768c75d30ed5559">More...</a><br /></td></tr>
<tr class="separator:a5f5c5d19b1f0355d9768c75d30ed5559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc865fa140c03c01a39d74b1f5c2416"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#acdc865fa140c03c01a39d74b1f5c2416">ft_memmove</a> (void *dst, const void *src, size_t len)</td></tr>
<tr class="memdesc:acdc865fa140c03c01a39d74b1f5c2416"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_memmove</b> &ndash; Copies memory area (<b>overlapping safe</b>).  <a href="libft_8h.html#acdc865fa140c03c01a39d74b1f5c2416">More...</a><br /></td></tr>
<tr class="separator:acdc865fa140c03c01a39d74b1f5c2416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf633e8e48a8afbe61947f61de5ac695"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#abf633e8e48a8afbe61947f61de5ac695">ft_memchr</a> (const void *s, int c, size_t n)</td></tr>
<tr class="memdesc:abf633e8e48a8afbe61947f61de5ac695"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_memchr</b> &ndash; Locate byte in byte string.  <a href="libft_8h.html#abf633e8e48a8afbe61947f61de5ac695">More...</a><br /></td></tr>
<tr class="separator:abf633e8e48a8afbe61947f61de5ac695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f665a1828c402f2ffe2e2187f135fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a08f665a1828c402f2ffe2e2187f135fc">ft_memcmp</a> (const void *s1, const void *s2, size_t n)</td></tr>
<tr class="memdesc:a08f665a1828c402f2ffe2e2187f135fc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_memcmp</b> &ndash; Compare memory areas.  <a href="libft_8h.html#a08f665a1828c402f2ffe2e2187f135fc">More...</a><br /></td></tr>
<tr class="separator:a08f665a1828c402f2ffe2e2187f135fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a6807f9f78ed4bf4f958323582d22f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#ae0a6807f9f78ed4bf4f958323582d22f">ft_calloc</a> (size_t count, size_t size)</td></tr>
<tr class="memdesc:ae0a6807f9f78ed4bf4f958323582d22f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_calloc</b> &ndash; Memory allocation.  <a href="libft_8h.html#ae0a6807f9f78ed4bf4f958323582d22f">More...</a><br /></td></tr>
<tr class="separator:ae0a6807f9f78ed4bf4f958323582d22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb8c6c4ed85d892e7f1509f65f5768a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#abbb8c6c4ed85d892e7f1509f65f5768a">ft_strlen</a> (const char *s)</td></tr>
<tr class="memdesc:abbb8c6c4ed85d892e7f1509f65f5768a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_strlen</b> &ndash; Gets length of a nul-terminated C string.  <a href="libft_8h.html#abbb8c6c4ed85d892e7f1509f65f5768a">More...</a><br /></td></tr>
<tr class="separator:abbb8c6c4ed85d892e7f1509f65f5768a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f759eb9793cf306fede66d0b7de0fc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a12f759eb9793cf306fede66d0b7de0fc">ft_strlcpy</a> (char *dst, const char *src, size_t dstsize)</td></tr>
<tr class="memdesc:a12f759eb9793cf306fede66d0b7de0fc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_strlcpy</b> &ndash; Copies a string.  <a href="libft_8h.html#a12f759eb9793cf306fede66d0b7de0fc">More...</a><br /></td></tr>
<tr class="separator:a12f759eb9793cf306fede66d0b7de0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7531453313e0cbfde6fe51662c9c3208"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a7531453313e0cbfde6fe51662c9c3208">ft_strlcat</a> (char *dst, const char *src, size_t dstsize)</td></tr>
<tr class="memdesc:a7531453313e0cbfde6fe51662c9c3208"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_strlcat</b> &ndash; Concatenate string.  <a href="libft_8h.html#a7531453313e0cbfde6fe51662c9c3208">More...</a><br /></td></tr>
<tr class="separator:a7531453313e0cbfde6fe51662c9c3208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d0c2d180f32ee585485e1a1ce3d55d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#aa6d0c2d180f32ee585485e1a1ce3d55d">ft_strchr</a> (const char *s, int c)</td></tr>
<tr class="memdesc:aa6d0c2d180f32ee585485e1a1ce3d55d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_strchr</b> &ndash; Locate character in string (left to right).  <a href="libft_8h.html#aa6d0c2d180f32ee585485e1a1ce3d55d">More...</a><br /></td></tr>
<tr class="separator:aa6d0c2d180f32ee585485e1a1ce3d55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c260cf80f9997975d6f3ec74ead582"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a49c260cf80f9997975d6f3ec74ead582">ft_strrchr</a> (const char *s, int c)</td></tr>
<tr class="memdesc:a49c260cf80f9997975d6f3ec74ead582"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_strrchr</b> &ndash; Locate character in string (right to left).  <a href="libft_8h.html#a49c260cf80f9997975d6f3ec74ead582">More...</a><br /></td></tr>
<tr class="separator:a49c260cf80f9997975d6f3ec74ead582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2fe792187aa4ed08e5864fb2c4d6dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a9d2fe792187aa4ed08e5864fb2c4d6dc">ft_strncmp</a> (const char *s1, const char *s2, size_t n)</td></tr>
<tr class="memdesc:a9d2fe792187aa4ed08e5864fb2c4d6dc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_strncmp</b> &ndash; Compare two strings.  <a href="libft_8h.html#a9d2fe792187aa4ed08e5864fb2c4d6dc">More...</a><br /></td></tr>
<tr class="separator:a9d2fe792187aa4ed08e5864fb2c4d6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00229613cc0bf361e86dca72ad92591"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#ae00229613cc0bf361e86dca72ad92591">ft_strnstr</a> (const char *haystack, const char *needle, size_t len)</td></tr>
<tr class="memdesc:ae00229613cc0bf361e86dca72ad92591"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_strnstr</b> &ndash; Locate a substring in a string.  <a href="libft_8h.html#ae00229613cc0bf361e86dca72ad92591">More...</a><br /></td></tr>
<tr class="separator:ae00229613cc0bf361e86dca72ad92591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad2ec371b4188602da9a94db687cb16"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#afad2ec371b4188602da9a94db687cb16">ft_atoi</a> (const char *str)</td></tr>
<tr class="memdesc:afad2ec371b4188602da9a94db687cb16"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_atoi</b> &ndash; .TODO.  <a href="libft_8h.html#afad2ec371b4188602da9a94db687cb16">More...</a><br /></td></tr>
<tr class="separator:afad2ec371b4188602da9a94db687cb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac2079a4250507c9af75d696f2ae476"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a2ac2079a4250507c9af75d696f2ae476">ft_strdup</a> (const char *s1)</td></tr>
<tr class="memdesc:a2ac2079a4250507c9af75d696f2ae476"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_strdup</b> &ndash; Saves a copy of a string.  <a href="libft_8h.html#a2ac2079a4250507c9af75d696f2ae476">More...</a><br /></td></tr>
<tr class="separator:a2ac2079a4250507c9af75d696f2ae476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c402cbf3d55b1374693c3b7d34f71d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a78c402cbf3d55b1374693c3b7d34f71d">ft_substr</a> (char const *s, unsigned int start, size_t len)</td></tr>
<tr class="memdesc:a78c402cbf3d55b1374693c3b7d34f71d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_substr</b> &ndash; Create new substring from original string.  <a href="libft_8h.html#a78c402cbf3d55b1374693c3b7d34f71d">More...</a><br /></td></tr>
<tr class="separator:a78c402cbf3d55b1374693c3b7d34f71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e6e3e428bcc9f2291b700e1829b82b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a91e6e3e428bcc9f2291b700e1829b82b">ft_strjoin</a> (char const *s1, char const *s2)</td></tr>
<tr class="memdesc:a91e6e3e428bcc9f2291b700e1829b82b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_strjoin</b> &ndash; Concatenates two strings resulting in new string.  <a href="libft_8h.html#a91e6e3e428bcc9f2291b700e1829b82b">More...</a><br /></td></tr>
<tr class="separator:a91e6e3e428bcc9f2291b700e1829b82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60352c5b39fab08469b3e28131a79e25"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a60352c5b39fab08469b3e28131a79e25">ft_strtrim</a> (char const *s1, char const *set)</td></tr>
<tr class="memdesc:a60352c5b39fab08469b3e28131a79e25"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_strtrim</b> &ndash; Trims string resulting in new string.  <a href="libft_8h.html#a60352c5b39fab08469b3e28131a79e25">More...</a><br /></td></tr>
<tr class="separator:a60352c5b39fab08469b3e28131a79e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65c9de65051c8c589286cf133c4a1f4"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#aa65c9de65051c8c589286cf133c4a1f4">ft_split</a> (char const *s, char c)</td></tr>
<tr class="memdesc:aa65c9de65051c8c589286cf133c4a1f4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_split</b> &ndash; Split string according to delimiter char.  <a href="libft_8h.html#aa65c9de65051c8c589286cf133c4a1f4">More...</a><br /></td></tr>
<tr class="separator:aa65c9de65051c8c589286cf133c4a1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6ea3765dfd826eabfc00d36e28ea38"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a8a6ea3765dfd826eabfc00d36e28ea38">ft_itoa</a> (int n)</td></tr>
<tr class="memdesc:a8a6ea3765dfd826eabfc00d36e28ea38"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_itoa</b> &ndash; Converts int to string representation.  <a href="libft_8h.html#a8a6ea3765dfd826eabfc00d36e28ea38">More...</a><br /></td></tr>
<tr class="separator:a8a6ea3765dfd826eabfc00d36e28ea38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610f39aa4bdf576a404e7dff6307db6c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a610f39aa4bdf576a404e7dff6307db6c">ft_itoa_b</a> (int n, unsigned int base, int in_caps)</td></tr>
<tr class="memdesc:a610f39aa4bdf576a404e7dff6307db6c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_ltoa_b</b> &ndash; .TODO.  <a href="libft_8h.html#a610f39aa4bdf576a404e7dff6307db6c">More...</a><br /></td></tr>
<tr class="separator:a610f39aa4bdf576a404e7dff6307db6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5cd31ca086eeda2e839722cbad3f51"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a4f5cd31ca086eeda2e839722cbad3f51">ft_get_sym_table</a> (char *sym_table, unsigned int base, int in_caps)</td></tr>
<tr class="memdesc:a4f5cd31ca086eeda2e839722cbad3f51"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_get_sym_table</b> &ndash; TODO.  <a href="libft_8h.html#a4f5cd31ca086eeda2e839722cbad3f51">More...</a><br /></td></tr>
<tr class="separator:a4f5cd31ca086eeda2e839722cbad3f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d84a6280527e8e890bf39a70512601"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a85d84a6280527e8e890bf39a70512601">ft_ltoa_b</a> (long n, unsigned int base, int in_caps)</td></tr>
<tr class="memdesc:a85d84a6280527e8e890bf39a70512601"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_ltoa_b</b> &ndash; .TODO.  <a href="libft_8h.html#a85d84a6280527e8e890bf39a70512601">More...</a><br /></td></tr>
<tr class="separator:a85d84a6280527e8e890bf39a70512601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7ca392832da91098199a661fa9527d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a9c7ca392832da91098199a661fa9527d">ft_ltoa</a> (long n)</td></tr>
<tr class="memdesc:a9c7ca392832da91098199a661fa9527d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_ltoa</b> &ndash; .TODO.  <a href="libft_8h.html#a9c7ca392832da91098199a661fa9527d">More...</a><br /></td></tr>
<tr class="separator:a9c7ca392832da91098199a661fa9527d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af747f6fc58589f60ad415f306b2c96d9"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#af747f6fc58589f60ad415f306b2c96d9">ft_ultoa_b</a> (unsigned long n, unsigned int base, int in_caps)</td></tr>
<tr class="memdesc:af747f6fc58589f60ad415f306b2c96d9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_ultoa_b</b> &ndash; .TODO.  <a href="libft_8h.html#af747f6fc58589f60ad415f306b2c96d9">More...</a><br /></td></tr>
<tr class="separator:af747f6fc58589f60ad415f306b2c96d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db52ad9f695362b5e2cc539c83b85c4"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a7db52ad9f695362b5e2cc539c83b85c4">ft_uitoa_b</a> (unsigned int n, unsigned int base, int in_caps)</td></tr>
<tr class="memdesc:a7db52ad9f695362b5e2cc539c83b85c4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_uitoa_b</b> &ndash; .TODO.  <a href="libft_8h.html#a7db52ad9f695362b5e2cc539c83b85c4">More...</a><br /></td></tr>
<tr class="separator:a7db52ad9f695362b5e2cc539c83b85c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668b60557bfc9d60c2d3ccda8afadf49"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a668b60557bfc9d60c2d3ccda8afadf49">ft_strmapi</a> (char const *s, char(*f)(unsigned int, char))</td></tr>
<tr class="memdesc:a668b60557bfc9d60c2d3ccda8afadf49"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_strmapi</b> &ndash; Apply a funtion to each char of a string.  <a href="libft_8h.html#a668b60557bfc9d60c2d3ccda8afadf49">More...</a><br /></td></tr>
<tr class="separator:a668b60557bfc9d60c2d3ccda8afadf49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada722cffd2c6c8169ae339afd0f9763c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#ada722cffd2c6c8169ae339afd0f9763c">ft_striteri</a> (char *s, void(*f)(unsigned int, char *))</td></tr>
<tr class="memdesc:ada722cffd2c6c8169ae339afd0f9763c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_striteri</b> &ndash; Modify a string applying a function to each of its chars.  <a href="libft_8h.html#ada722cffd2c6c8169ae339afd0f9763c">More...</a><br /></td></tr>
<tr class="separator:ada722cffd2c6c8169ae339afd0f9763c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee15a511946c1397bd2bdea4aed6aee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a8ee15a511946c1397bd2bdea4aed6aee">ft_putchar_fd</a> (char c, int fd)</td></tr>
<tr class="memdesc:a8ee15a511946c1397bd2bdea4aed6aee"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_putchar_fd</b> &ndash; .TODO.  <a href="libft_8h.html#a8ee15a511946c1397bd2bdea4aed6aee">More...</a><br /></td></tr>
<tr class="separator:a8ee15a511946c1397bd2bdea4aed6aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefce9ac519f8f8b7d3fde33dbafe469"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#acefce9ac519f8f8b7d3fde33dbafe469">ft_putstr_fd</a> (char *s, int fd)</td></tr>
<tr class="memdesc:acefce9ac519f8f8b7d3fde33dbafe469"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_putstr_fd</b> &ndash; .TODO.  <a href="libft_8h.html#acefce9ac519f8f8b7d3fde33dbafe469">More...</a><br /></td></tr>
<tr class="separator:acefce9ac519f8f8b7d3fde33dbafe469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb112152acfc553d58d61a5df38afcde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#aeb112152acfc553d58d61a5df38afcde">ft_putendl_fd</a> (char *s, int fd)</td></tr>
<tr class="memdesc:aeb112152acfc553d58d61a5df38afcde"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_putendl_fd</b> &ndash; .TODO.  <a href="libft_8h.html#aeb112152acfc553d58d61a5df38afcde">More...</a><br /></td></tr>
<tr class="separator:aeb112152acfc553d58d61a5df38afcde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63cc0aec12256d125d3f85e472280972"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a63cc0aec12256d125d3f85e472280972">ft_putnbr_fd</a> (int n, int fd)</td></tr>
<tr class="memdesc:a63cc0aec12256d125d3f85e472280972"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_putnbr_fd</b> &ndash; .TODO.  <a href="libft_8h.html#a63cc0aec12256d125d3f85e472280972">More...</a><br /></td></tr>
<tr class="separator:a63cc0aec12256d125d3f85e472280972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b74034df822be1f6c45484cb01f01a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a3b74034df822be1f6c45484cb01f01a7">ft_pow</a> (int base, unsigned int exp)</td></tr>
<tr class="memdesc:a3b74034df822be1f6c45484cb01f01a7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_pow</b> &ndash; Power function.  <a href="libft_8h.html#a3b74034df822be1f6c45484cb01f01a7">More...</a><br /></td></tr>
<tr class="separator:a3b74034df822be1f6c45484cb01f01a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1bcb2ef112f7ad073d507a0c6be4d2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a0a1bcb2ef112f7ad073d507a0c6be4d2">ft_print_memory</a> (void *addr, unsigned int size)</td></tr>
<tr class="memdesc:a0a1bcb2ef112f7ad073d507a0c6be4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_print_memory</b> &ndash; .TODO.  <a href="libft_8h.html#a0a1bcb2ef112f7ad073d507a0c6be4d2">More...</a><br /></td></tr>
<tr class="separator:a0a1bcb2ef112f7ad073d507a0c6be4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5537837dd84bbafbe048446ac89edf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#ace5537837dd84bbafbe048446ac89edf">ft_putchar_fd_safe</a> (char c, int fd)</td></tr>
<tr class="memdesc:ace5537837dd84bbafbe048446ac89edf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_putchar_fd_safe</b> &ndash; TODO..  <a href="libft_8h.html#ace5537837dd84bbafbe048446ac89edf">More...</a><br /></td></tr>
<tr class="separator:ace5537837dd84bbafbe048446ac89edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b37f8f02a3ced682c7f1f874b1b144"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#ac8b37f8f02a3ced682c7f1f874b1b144">ft_putstr_fd_safe</a> (char *s, int fd)</td></tr>
<tr class="memdesc:ac8b37f8f02a3ced682c7f1f874b1b144"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_putstr_fd_safe</b> &ndash; TODO.  <a href="libft_8h.html#ac8b37f8f02a3ced682c7f1f874b1b144">More...</a><br /></td></tr>
<tr class="separator:ac8b37f8f02a3ced682c7f1f874b1b144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe4ea6f56f5a2a75ee13d97416b60ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libft_8h.html#aefde00352c5326bb1c28ebd4404c4795">t_list</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a8fe4ea6f56f5a2a75ee13d97416b60ed">ft_lstnew</a> (void *content)</td></tr>
<tr class="memdesc:a8fe4ea6f56f5a2a75ee13d97416b60ed"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_lstnew</b> &ndash; Create a list element from pointer to its content.  <a href="libft_8h.html#a8fe4ea6f56f5a2a75ee13d97416b60ed">More...</a><br /></td></tr>
<tr class="separator:a8fe4ea6f56f5a2a75ee13d97416b60ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0195e4eb88fad15717ed90524ac15771"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a0195e4eb88fad15717ed90524ac15771">ft_lstadd_front</a> (<a class="el" href="libft_8h.html#aefde00352c5326bb1c28ebd4404c4795">t_list</a> **lst, <a class="el" href="libft_8h.html#aefde00352c5326bb1c28ebd4404c4795">t_list</a> *new)</td></tr>
<tr class="memdesc:a0195e4eb88fad15717ed90524ac15771"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_lstadd_front</b> &ndash; Adds node at the beginning of the list.  <a href="libft_8h.html#a0195e4eb88fad15717ed90524ac15771">More...</a><br /></td></tr>
<tr class="separator:a0195e4eb88fad15717ed90524ac15771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da614988ac99446db9df99d2c773fc1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a9da614988ac99446db9df99d2c773fc1">ft_lstsize</a> (<a class="el" href="libft_8h.html#aefde00352c5326bb1c28ebd4404c4795">t_list</a> *lst)</td></tr>
<tr class="memdesc:a9da614988ac99446db9df99d2c773fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_lstsize</b> &ndash; Counts the number of nodes in a list.  <a href="libft_8h.html#a9da614988ac99446db9df99d2c773fc1">More...</a><br /></td></tr>
<tr class="separator:a9da614988ac99446db9df99d2c773fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5f9b5ecc45235a7b7cf9d4b24e43dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libft_8h.html#aefde00352c5326bb1c28ebd4404c4795">t_list</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#aed5f9b5ecc45235a7b7cf9d4b24e43dc">ft_lstlast</a> (<a class="el" href="libft_8h.html#aefde00352c5326bb1c28ebd4404c4795">t_list</a> *lst)</td></tr>
<tr class="memdesc:aed5f9b5ecc45235a7b7cf9d4b24e43dc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_lstlast</b> &ndash; Returns the last node of the list.  <a href="libft_8h.html#aed5f9b5ecc45235a7b7cf9d4b24e43dc">More...</a><br /></td></tr>
<tr class="separator:aed5f9b5ecc45235a7b7cf9d4b24e43dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c10e88fffc3c9467eb16e6debd227a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a4c10e88fffc3c9467eb16e6debd227a4">ft_lstadd_back</a> (<a class="el" href="libft_8h.html#aefde00352c5326bb1c28ebd4404c4795">t_list</a> **lst, <a class="el" href="libft_8h.html#aefde00352c5326bb1c28ebd4404c4795">t_list</a> *new)</td></tr>
<tr class="memdesc:a4c10e88fffc3c9467eb16e6debd227a4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_lstadd_back</b> &ndash; Adds the node ’new’ at the end of the list.  <a href="libft_8h.html#a4c10e88fffc3c9467eb16e6debd227a4">More...</a><br /></td></tr>
<tr class="separator:a4c10e88fffc3c9467eb16e6debd227a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b881501f9ee2f3ed5718f6d9ebee7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#ac2b881501f9ee2f3ed5718f6d9ebee7c">ft_lstdelone</a> (<a class="el" href="libft_8h.html#aefde00352c5326bb1c28ebd4404c4795">t_list</a> *lst, void(*del)(void *))</td></tr>
<tr class="memdesc:ac2b881501f9ee2f3ed5718f6d9ebee7c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_lstdelone</b> &ndash; Deletes and frees memory of item list and its content.  <a href="libft_8h.html#ac2b881501f9ee2f3ed5718f6d9ebee7c">More...</a><br /></td></tr>
<tr class="separator:ac2b881501f9ee2f3ed5718f6d9ebee7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e900cfaea2857bbf490f3105e38da93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a6e900cfaea2857bbf490f3105e38da93">ft_lstclear</a> (<a class="el" href="libft_8h.html#aefde00352c5326bb1c28ebd4404c4795">t_list</a> **lst, void(*del)(void *))</td></tr>
<tr class="memdesc:a6e900cfaea2857bbf490f3105e38da93"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_lstclear</b> &ndash; Deletes and frees given node and succesors. (freeing contents).  <a href="libft_8h.html#a6e900cfaea2857bbf490f3105e38da93">More...</a><br /></td></tr>
<tr class="separator:a6e900cfaea2857bbf490f3105e38da93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1888c62a89ec3d206f2ed4590f4a021d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a1888c62a89ec3d206f2ed4590f4a021d">ft_lstiter</a> (<a class="el" href="libft_8h.html#aefde00352c5326bb1c28ebd4404c4795">t_list</a> *lst, void(*f)(void *))</td></tr>
<tr class="memdesc:a1888c62a89ec3d206f2ed4590f4a021d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_lstiter</b> &ndash; Applies function f to the content of each node on list.  <a href="libft_8h.html#a1888c62a89ec3d206f2ed4590f4a021d">More...</a><br /></td></tr>
<tr class="separator:a1888c62a89ec3d206f2ed4590f4a021d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8198d1837ffbba05823f5e85afebf9c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libft_8h.html#aefde00352c5326bb1c28ebd4404c4795">t_list</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libft_8h.html#a8198d1837ffbba05823f5e85afebf9c6">ft_lstmap</a> (<a class="el" href="libft_8h.html#aefde00352c5326bb1c28ebd4404c4795">t_list</a> *lst, void *(*f)(void *), void(*del)(void *))</td></tr>
<tr class="memdesc:a8198d1837ffbba05823f5e85afebf9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ft_lstmap</b> &ndash; Returns new list based on applying f to each nodes content.  <a href="libft_8h.html#a8198d1837ffbba05823f5e85afebf9c6">More...</a><br /></td></tr>
<tr class="separator:a8198d1837ffbba05823f5e85afebf9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Public header file for libft library. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aefde00352c5326bb1c28ebd4404c4795" name="aefde00352c5326bb1c28ebd4404c4795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefde00352c5326bb1c28ebd4404c4795">&#9670;&nbsp;</a></span>t_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structs__list.html">s_list</a> <a class="el" href="libft_8h.html#aefde00352c5326bb1c28ebd4404c4795">t_list</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>t_list</b> &ndash; Typedef struct for a dynamic list node </p>
<p >This type is used as a node for a one-way dynamic list. Any node could serve as a list for itself (i.e. as the beginning of a list).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">content</td><td>- Pointer to void to allow caller to use arbitrary type.</td></tr>
    <tr><td class="paramname">next</td><td>- Pointer to next node of the list. NULL if last node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="afad2ec371b4188602da9a94db687cb16" name="afad2ec371b4188602da9a94db687cb16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad2ec371b4188602da9a94db687cb16">&#9670;&nbsp;</a></span>ft_atoi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ft_atoi </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_atoi</b> &ndash; .TODO. </p>
<p >Some_detailed_description.TODO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td>.TODO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TODO.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>TODO. <br  />
 A NULL pointer parameter or a non-terminated string are supposed to make this function crash.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 TODO. </dd></dl>

</div>
</div>
<a id="a5937ab0d08e31d0e3e4a16ec71e293a1" name="a5937ab0d08e31d0e3e4a16ec71e293a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5937ab0d08e31d0e3e4a16ec71e293a1">&#9670;&nbsp;</a></span>ft_bzero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ft_bzero </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_bzero</b> &ndash; Fills memory with zeros. </p>
<p >Writes n bytes with 0 starting at s memory position. Uses <a class="el" href="libft_8h.html#a19d0a16cec67fe4c1af22f1571f4f8a6" title="ft_memset – Fills memory with a constant byte.">ft_memset()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">s</td><td>- Pointer to first address.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>- Bytes to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- None.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>A NULL pointer parameter or an improper len (invasion of forbidden memory space) are supposed to make this function crash. </dd></dl>

</div>
</div>
<a id="ae0a6807f9f78ed4bf4f958323582d22f" name="ae0a6807f9f78ed4bf4f958323582d22f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a6807f9f78ed4bf4f958323582d22f">&#9670;&nbsp;</a></span>ft_calloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ft_calloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_calloc</b> &ndash; Memory allocation. </p>
<p >The <a class="el" href="libft_8h.html#ae0a6807f9f78ed4bf4f958323582d22f" title="ft_calloc – Memory allocation.">ft_calloc()</a> function contiguously allocates enough space for count objects that are size bytes of memory each and returns a pointer to the allocated memory. The allocated memory is filled with bytes of value zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>- The number of objects.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>- The size in bytes of one object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, <a class="el" href="libft_8h.html#ae0a6807f9f78ed4bf4f958323582d22f" title="ft_calloc – Memory allocation.">ft_calloc()</a> function returns a pointer to allocated memory. <br  />
 If there is an error, it returns a NULL pointer.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: malloc(). </dd></dl>

</div>
</div>
<a id="a4f5cd31ca086eeda2e839722cbad3f51" name="a4f5cd31ca086eeda2e839722cbad3f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f5cd31ca086eeda2e839722cbad3f51">&#9670;&nbsp;</a></span>ft_get_sym_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ft_get_sym_table </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>sym_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in_caps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_get_sym_table</b> &ndash; TODO. </p>
<p >Some_detailed_description.TODO</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td>.TODO</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TODO</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>TODO</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 TODO </dd></dl>

</div>
</div>
<a id="a9c2c3821ea43ebdf97de07b123503f8b" name="a9c2c3821ea43ebdf97de07b123503f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c2c3821ea43ebdf97de07b123503f8b">&#9670;&nbsp;</a></span>ft_isalnum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ft_isalnum </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_isalnum</b> &ndash; Checks for an alphanumeric character. </p>
<p >Uses <a class="el" href="libft_8h.html#ac283963beaa3b8c7d09b78851cda297e" title="ft_isalpha – Checks for an alphabetic character.">ft_isalpha()</a> and <a class="el" href="libft_8h.html#a2cf15b8a1a277d1e2ce3654101a2003d" title="ft_isdigit – Checks for a digit character.">ft_isdigit()</a> to evaluate if c is an alphanumeric character ('A' - 'Z' or 'a' to 'z' or '0' to '9').</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>- The character to evaluate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if c is an alphanumeric character. </dd></dl>

</div>
</div>
<a id="ac283963beaa3b8c7d09b78851cda297e" name="ac283963beaa3b8c7d09b78851cda297e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac283963beaa3b8c7d09b78851cda297e">&#9670;&nbsp;</a></span>ft_isalpha()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ft_isalpha </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_isalpha</b> &ndash; Checks for an alphabetic character. </p>
<p >Uses <a class="el" href="libft_8h.html#a1ad9c4559cffbb211ec56fe8964f30f9" title="ft_isupper – Tests for uppercase alphabetic character.">ft_isupper()</a> and <a class="el" href="libft_8h.html#a2643d7f2fbcb6d5567a22d8f19e0ad70" title="ft_islower – Tests for lowercase alphabetic character.">ft_islower()</a> to evaluate if c is an alphabetic character ('A' - 'Z' or 'a' to 'z').</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>- The character to evaluate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if c is an alphabetic character. </dd></dl>

</div>
</div>
<a id="abf60ddbec6479540e81f3648cf71f1f4" name="abf60ddbec6479540e81f3648cf71f1f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf60ddbec6479540e81f3648cf71f1f4">&#9670;&nbsp;</a></span>ft_isascii()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ft_isascii </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_isascii</b> &ndash; Checks for (basic) ASCII character. </p>
<p >Checks if argument fits in 7-bit ASCII (basic, universal ASCII). That is, from 00 to 0177 (decimal 0 to 127).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>- The character to evaluate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if c is an ASCII character; 0 otherwise. </dd></dl>

</div>
</div>
<a id="a2cf15b8a1a277d1e2ce3654101a2003d" name="a2cf15b8a1a277d1e2ce3654101a2003d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf15b8a1a277d1e2ce3654101a2003d">&#9670;&nbsp;</a></span>ft_isdigit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ft_isdigit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_isdigit</b> &ndash; Checks for a digit character. </p>
<p >Evaluate if c is a digit character ('0' - '9').</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>- The character to evaluate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if c is a digit character. </dd></dl>

</div>
</div>
<a id="a2643d7f2fbcb6d5567a22d8f19e0ad70" name="a2643d7f2fbcb6d5567a22d8f19e0ad70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2643d7f2fbcb6d5567a22d8f19e0ad70">&#9670;&nbsp;</a></span>ft_islower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ft_islower </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_islower</b> &ndash; Tests for lowercase alphabetic character. </p>
<p >Evaluate if c is a lowercase alphabetic character ('a' - 'z'). The value of the argument must be representable as an unsigned char or the value of EOF.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>- The character to evaluate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if c is an lowercase alphabetic character. </dd></dl>

</div>
</div>
<a id="abcdba69692f21146aeea5b3d59b7d0ca" name="abcdba69692f21146aeea5b3d59b7d0ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcdba69692f21146aeea5b3d59b7d0ca">&#9670;&nbsp;</a></span>ft_isprint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ft_isprint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_isprint</b> &ndash; Checks for printable (basic) ASCII character. </p>
<p >Checks if argument fits in the range of 040 to 0176 (decimal 32 to 126). That is, the printable characters range in 7 bits basic, universal ASCII).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>- The character to evaluate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if c is an printable basic ASCII character; 0 otherwise. </dd></dl>

</div>
</div>
<a id="ac9bd1a8fd96208017945d589974efc65" name="ac9bd1a8fd96208017945d589974efc65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9bd1a8fd96208017945d589974efc65">&#9670;&nbsp;</a></span>ft_issign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ft_issign </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_issign</b> &ndash; Checks for a '+' '-' character. </p>
<p >Evaluate if c is a sign (i.e. any of '+' '-' characters).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>- The character to evaluate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if c is a sign character (+1 for '+' or -1 for '-'). <br  />
 Returns 0 if not a sign character. </dd></dl>

</div>
</div>
<a id="a76cd21d0fd288012f02809cba504f650" name="a76cd21d0fd288012f02809cba504f650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76cd21d0fd288012f02809cba504f650">&#9670;&nbsp;</a></span>ft_isspace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ft_isspace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_isspace</b> &ndash; White-space (in the broad sense) character test. </p>
<p >The <a class="el" href="libft_8h.html#a76cd21d0fd288012f02809cba504f650" title="ft_isspace – White-space (in the broad sense) character test.">ft_isspace()</a> function tests for the white-space characters. <br  />
 This includes the following standard characters: <br  />
 '\t' '<br  />
' '\v' '\f' '\r' ' '</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>- The character to evaluate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if c is a white space in the broad sense; 0 otherwise. </dd></dl>

</div>
</div>
<a id="a1ad9c4559cffbb211ec56fe8964f30f9" name="a1ad9c4559cffbb211ec56fe8964f30f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad9c4559cffbb211ec56fe8964f30f9">&#9670;&nbsp;</a></span>ft_isupper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ft_isupper </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_isupper</b> &ndash; Tests for uppercase alphabetic character. </p>
<p >Evaluate if c is an uppercase alphabetic character ('A' - 'Z'). <br  />
 The value of the argument must be representable as an unsigned char or the value of EOF.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>- The character to evaluate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if c is an uppercase alphabetic character. </dd></dl>

</div>
</div>
<a id="a8a6ea3765dfd826eabfc00d36e28ea38" name="a8a6ea3765dfd826eabfc00d36e28ea38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6ea3765dfd826eabfc00d36e28ea38">&#9670;&nbsp;</a></span>ft_itoa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ft_itoa </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_itoa</b> &ndash; Converts int to string representation. </p>
<p >Allocates (with malloc()) and returns a string representing the integer received as an argument. <br  />
 Negative numbers must be handled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td>.TODO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representing the integer. <br  />
 NULL if the allocation fails.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: malloc(). <br  />
 A NULL pointer parameter or a non-terminated string are supposed to make this function crash.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 TODO. </dd></dl>

</div>
</div>
<a id="a610f39aa4bdf576a404e7dff6307db6c" name="a610f39aa4bdf576a404e7dff6307db6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610f39aa4bdf576a404e7dff6307db6c">&#9670;&nbsp;</a></span>ft_itoa_b()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ft_itoa_b </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in_caps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_ltoa_b</b> &ndash; .TODO. </p>
<p >Some_detailed_description.TODO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td>.TODO.</td></tr>
    <tr><td class="paramname">in_caps</td><td>- If hexadecimal, when != 0 uses abcdef instead of ABCDEF.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TODO.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: malloc(). <br  />
 A NULL pointer parameter or a non-terminated string are supposed to make this function crash. TODO</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 TODO. </dd></dl>

</div>
</div>
<a id="a4c10e88fffc3c9467eb16e6debd227a4" name="a4c10e88fffc3c9467eb16e6debd227a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c10e88fffc3c9467eb16e6debd227a4">&#9670;&nbsp;</a></span>ft_lstadd_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ft_lstadd_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libft_8h.html#aefde00352c5326bb1c28ebd4404c4795">t_list</a> **&#160;</td>
          <td class="paramname"><em>lst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libft_8h.html#aefde00352c5326bb1c28ebd4404c4795">t_list</a> *&#160;</td>
          <td class="paramname"><em>new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_lstadd_back</b> &ndash; Adds the node ’new’ at the end of the list. </p>
<p >Adds the node ’new’ at the end of the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lst</td><td>- The address of a pointer to the first link of a list.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">-</td><td>The address of a pointer to the node to be added to the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>TODO.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 If lst == NULL or new == NULL, nothing must be done. <br  />
 If *lst == NULL &gt;&gt; *lst = new (i.e. lstadd_backing an element to a NULL list, creates the list with just that element). </dd></dl>

</div>
</div>
<a id="a0195e4eb88fad15717ed90524ac15771" name="a0195e4eb88fad15717ed90524ac15771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0195e4eb88fad15717ed90524ac15771">&#9670;&nbsp;</a></span>ft_lstadd_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ft_lstadd_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libft_8h.html#aefde00352c5326bb1c28ebd4404c4795">t_list</a> **&#160;</td>
          <td class="paramname"><em>lst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libft_8h.html#aefde00352c5326bb1c28ebd4404c4795">t_list</a> *&#160;</td>
          <td class="paramname"><em>new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_lstadd_front</b> &ndash; Adds node at the beginning of the list. </p>
<p >Adds the node ’new’ at the beginning of the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lst</td><td>- The address of a pointer to the first link of a list.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new</td><td>- The address of a pointer to the node to be added to the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: malloc(). <br  />
 TODO</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 lst == NULL. <br  />
 *lst == NULL. <br  />
 t_list == NULL. <br  />
 TODO. </dd></dl>

</div>
</div>
<a id="a6e900cfaea2857bbf490f3105e38da93" name="a6e900cfaea2857bbf490f3105e38da93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e900cfaea2857bbf490f3105e38da93">&#9670;&nbsp;</a></span>ft_lstclear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ft_lstclear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libft_8h.html#aefde00352c5326bb1c28ebd4404c4795">t_list</a> **&#160;</td>
          <td class="paramname"><em>lst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>del</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_lstclear</b> &ndash; Deletes and frees given node and succesors. (freeing contents). </p>
<p >Deletes and frees the given node and every successor of that node, using the function ’del’ and free(). <br  />
 Finally, the pointer to the list must be set to NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lst-</td><td>The address of a pointer to a node.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">del</td><td>- The address of the function used to delete the content of the node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: free(). <br  />
 TODO.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 If lst == NULL, nothing must be done. <br  />
 If *lst == NULL, nothing must be done. <br  />
 Parameter lst MUST be set to NULL by this function. <br  />
 Function del() must handle NULL content but must not free the node. </dd></dl>

</div>
</div>
<a id="ac2b881501f9ee2f3ed5718f6d9ebee7c" name="ac2b881501f9ee2f3ed5718f6d9ebee7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b881501f9ee2f3ed5718f6d9ebee7c">&#9670;&nbsp;</a></span>ft_lstdelone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ft_lstdelone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libft_8h.html#aefde00352c5326bb1c28ebd4404c4795">t_list</a> *&#160;</td>
          <td class="paramname"><em>lst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>del</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_lstdelone</b> &ndash; Deletes and frees memory of item list and its content. </p>
<p >Takes as a parameter a node and frees the memory of the node’s content using the function ’del’ given as a parameter and free the node. <br  />
 The memory of ’next’ must not be freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lst</td><td>- The node to free.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">del</td><td>- The address of the function used to delete the content.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: free(). <br  />
 TODO.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 CONCEPTUAL: Could break a list because no first item of list nor previous item is given. This is the expected behavior. <br  />
 The caller should set lst to NULL after freeing the memory with this funcion. <br  />
 Function del() must handle NULL content but must not free the node. </dd></dl>

</div>
</div>
<a id="a1888c62a89ec3d206f2ed4590f4a021d" name="a1888c62a89ec3d206f2ed4590f4a021d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1888c62a89ec3d206f2ed4590f4a021d">&#9670;&nbsp;</a></span>ft_lstiter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ft_lstiter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libft_8h.html#aefde00352c5326bb1c28ebd4404c4795">t_list</a> *&#160;</td>
          <td class="paramname"><em>lst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_lstiter</b> &ndash; Applies function f to the content of each node on list. </p>
<p >Iterates the list ’lst’ and applies the function ’f’ on the content of each node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lst</td><td>- The address of a pointer to a node.</td></tr>
    <tr><td class="paramname">f</td><td>- The address of the function used to iterate on the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>TODO.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 If lst == NULL, return NULL. <br  />
 CONCEPTUAL: f fuction must handle NULL content: f() must return NULL, also if its malloc() call fails. f() must return the address of the new content. </dd></dl>

</div>
</div>
<a id="aed5f9b5ecc45235a7b7cf9d4b24e43dc" name="aed5f9b5ecc45235a7b7cf9d4b24e43dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5f9b5ecc45235a7b7cf9d4b24e43dc">&#9670;&nbsp;</a></span>ft_lstlast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libft_8h.html#aefde00352c5326bb1c28ebd4404c4795">t_list</a> * ft_lstlast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libft_8h.html#aefde00352c5326bb1c28ebd4404c4795">t_list</a> *&#160;</td>
          <td class="paramname"><em>lst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_lstlast</b> &ndash; Returns the last node of the list. </p>
<p >Returns the last node of the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lst</td><td>- The beginning of the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Last node of the list.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>TODO.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 If lst == NULL, return value is NULL. </dd></dl>

</div>
</div>
<a id="a8198d1837ffbba05823f5e85afebf9c6" name="a8198d1837ffbba05823f5e85afebf9c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8198d1837ffbba05823f5e85afebf9c6">&#9670;&nbsp;</a></span>ft_lstmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libft_8h.html#aefde00352c5326bb1c28ebd4404c4795">t_list</a> * ft_lstmap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libft_8h.html#aefde00352c5326bb1c28ebd4404c4795">t_list</a> *&#160;</td>
          <td class="paramname"><em>lst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>del</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_lstmap</b> &ndash; Returns new list based on applying f to each nodes content. </p>
<p >Iterates the list ’lst’ and applies the function ’f’ on the content of each node. Creates a new list resulting of the successive applications of the function ’f’. The ’del’ function is used to delete the content of a node if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lst</td><td>- The address of a pointer to a node.</td></tr>
    <tr><td class="paramname">f</td><td>- The address of the function used to iterate on the list.</td></tr>
    <tr><td class="paramname">del</td><td>- The address of the function used to delete the content of a node if needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new list. <br  />
 NULL if the allocation fails.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: malloc(), free(). <br  />
 TODO.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 CONCEPTUAL: f fuction must handle NULL content: f() must return NULL, also if its malloc() call fails. f() must return the address of the new content. <br  />
 Function del() must handle NULL content but must not free the node. <br  />
 If at some point the funcion fails, the in-construction new list must be cleared completely and NULL must be returned. </dd></dl>

</div>
</div>
<a id="a8fe4ea6f56f5a2a75ee13d97416b60ed" name="a8fe4ea6f56f5a2a75ee13d97416b60ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe4ea6f56f5a2a75ee13d97416b60ed">&#9670;&nbsp;</a></span>ft_lstnew()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libft_8h.html#aefde00352c5326bb1c28ebd4404c4795">t_list</a> * ft_lstnew </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>content</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_lstnew</b> &ndash; Create a list element from pointer to its content. </p>
<p >Allocates (with malloc()) and returns a new node. <br  />
 The member variable ’content’ is initialized with the value of the parameter ’content’. The variable ’next’ is initialized to NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">content</td><td>- The content to create the node with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new node.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: ???. <br  />
 TODO. <br  />
 A NULL pointer parameter or a non-terminated string are supposed to make this function crash.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 If content == NULL, must return NULL. <br  />
 If malloc fails, must return NULL. </dd></dl>

</div>
</div>
<a id="a9da614988ac99446db9df99d2c773fc1" name="a9da614988ac99446db9df99d2c773fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da614988ac99446db9df99d2c773fc1">&#9670;&nbsp;</a></span>ft_lstsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ft_lstsize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libft_8h.html#aefde00352c5326bb1c28ebd4404c4795">t_list</a> *&#160;</td>
          <td class="paramname"><em>lst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_lstsize</b> &ndash; Counts the number of nodes in a list. </p>
<p >Counts the number of nodes in a list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lst</td><td>- The beginning of the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the list.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>TODO.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 If lst == NULL, return value must be 0. </dd></dl>

</div>
</div>
<a id="a9c7ca392832da91098199a661fa9527d" name="a9c7ca392832da91098199a661fa9527d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7ca392832da91098199a661fa9527d">&#9670;&nbsp;</a></span>ft_ltoa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ft_ltoa </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_ltoa</b> &ndash; .TODO. </p>
<p >Some_detailed_description.TODO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td>.TODO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TODO.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: malloc(). <br  />
 A NULL pointer parameter or a non-terminated string are supposed to make this function crash.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 TODO. </dd></dl>

</div>
</div>
<a id="a85d84a6280527e8e890bf39a70512601" name="a85d84a6280527e8e890bf39a70512601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d84a6280527e8e890bf39a70512601">&#9670;&nbsp;</a></span>ft_ltoa_b()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ft_ltoa_b </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in_caps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_ltoa_b</b> &ndash; .TODO. </p>
<p >Some_detailed_description.TODO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td>.TODO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TODO.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: malloc(). <br  />
 A NULL pointer parameter or a non-terminated string are supposed to make this function crash. TODO</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 TODO. </dd></dl>

</div>
</div>
<a id="abf633e8e48a8afbe61947f61de5ac695" name="abf633e8e48a8afbe61947f61de5ac695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf633e8e48a8afbe61947f61de5ac695">&#9670;&nbsp;</a></span>ft_memchr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ft_memchr </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_memchr</b> &ndash; Locate byte in byte string. </p>
<p >The <a class="el" href="libft_8h.html#abf633e8e48a8afbe61947f61de5ac695" title="ft_memchr – Locate byte in byte string.">ft_memchr()</a> function locates the first occurrence of c (converted to an unsigned char) in the first n bytes of string s.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>- The start address for the search.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>- The byte to search for (interpreted as unsigned char).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>- The start address for the search.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the byte located. <br  />
 NULL if no such byte exists within n bytes or if n == 0.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>A NULL pointer parameter is supposed to make this function crash.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 A n == 0 parameter is also supposed to return a NULL pointer. </dd></dl>

</div>
</div>
<a id="a08f665a1828c402f2ffe2e2187f135fc" name="a08f665a1828c402f2ffe2e2187f135fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f665a1828c402f2ffe2e2187f135fc">&#9670;&nbsp;</a></span>ft_memcmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ft_memcmp </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_memcmp</b> &ndash; Compare memory areas. </p>
<p >The <a class="el" href="libft_8h.html#a08f665a1828c402f2ffe2e2187f135fc" title="ft_memcmp – Compare memory areas.">ft_memcmp()</a> function compares the first n bytes (each interpreted as unsigned char) of the memory areas s1 and s2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s1</td><td>- Address of first memory area.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s2</td><td>- Address of second memory area.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>- Amount of bytes to compare from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a 0 if both memory area are equal or if n == 0. <br  />
 Returns a positive or negative number if different. <br  />
 Specifically the returned value comes from the first different byte found as the difference between the numeric value of s1's byte minus the numeric value of s2's byte.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>NULL pointers parameters are supposed to make this function crash. </dd></dl>

</div>
</div>
<a id="a5f5c5d19b1f0355d9768c75d30ed5559" name="a5f5c5d19b1f0355d9768c75d30ed5559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f5c5d19b1f0355d9768c75d30ed5559">&#9670;&nbsp;</a></span>ft_memcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ft_memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_memcpy</b> &ndash; Copies memory area (<b>overlapping unsafe</b>). </p>
<p >The <a class="el" href="libft_8h.html#a5f5c5d19b1f0355d9768c75d30ed5559" title="ft_memcpy – Copies memory area (overlapping unsafe).">ft_memcpy()</a> function copies n bytes from memory area src to memory area dst. <br  />
 <b>If dst and src overlap, behavior is undefined</b>. Applications in which dst and src might overlap should use <a class="el" href="libft_8h.html#acdc865fa140c03c01a39d74b1f5c2416" title="ft_memmove – Copies memory area (overlapping safe).">ft_memmove()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dst</td><td>- Pointer to destination (start of memory to be written).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>- Pointer to source (address of first byte to copy).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>- Amount of bytes to be copied from src to dst.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- The original value of pointer dst.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If dst and src are <b>both</b> NULL <b>or</b> n == 0, the function <b>does nothing</b>, just returns dst. <br  />
 When n != 0 this function is supposed to fail <b>only if either src or dst are NULL</b>. <br  />
 If dst and src overlap the <b>behaviour is undefined</b>. <br  />
 An improper n (invasion of forbidden memory space) is supposed to make this function crash. </dd></dl>

</div>
</div>
<a id="acdc865fa140c03c01a39d74b1f5c2416" name="acdc865fa140c03c01a39d74b1f5c2416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc865fa140c03c01a39d74b1f5c2416">&#9670;&nbsp;</a></span>ft_memmove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ft_memmove </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_memmove</b> &ndash; Copies memory area (<b>overlapping safe</b>). </p>
<p >The <a class="el" href="libft_8h.html#acdc865fa140c03c01a39d74b1f5c2416" title="ft_memmove – Copies memory area (overlapping safe).">ft_memmove()</a> function copies len bytes from string src to string dst. <br  />
 The two strings may overlap; the copy is always done in a non-destructive manner.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dst</td><td>- Pointer to destination (start of memory to be written).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>- Pointer to source (address of first byte to copy).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>- Amount of bytes to be copied from src to dst.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- The original value of pointer dst.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If dst and src are <b>both</b> NULL <b>or</b> n == 0, the function <b>does nothing</b>, just returns dst. <br  />
 When len != 0 this function is supposed to fail <b>only if either src or dst are NULL</b>. <br  />
 An improper len (invasion of forbidden memory space) is supposed to make <br  />
 this function crash.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 If destination overlaps source, it is possible that at some point the original data in source gets corrupted before it's been copied into dst. <br  />
 Problematic case: If reading src from the beginning <br  />
 dst &gt; src &amp;&amp; src + len &gt; dst <br  />
 0123456789012345678901234567 <br  />
 ssssssssssssssssssssssss <br  />
 dddddddddddddddddddddddd <br  />
 In order to avoid this, src must be read from the end in this case. </dd></dl>

</div>
</div>
<a id="a19d0a16cec67fe4c1af22f1571f4f8a6" name="a19d0a16cec67fe4c1af22f1571f4f8a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d0a16cec67fe4c1af22f1571f4f8a6">&#9670;&nbsp;</a></span>ft_memset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ft_memset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_memset</b> &ndash; Fills memory with a constant byte. </p>
<p >Writes len bytes with c (unsigned char casted) starting at b memory position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>- Pointer to first address.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>- Integer with the value (unsigned char casted) to write.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>- Bytes to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- The original pointer passed as function argument.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>A NULL pointer parameter or an improper len (invasion of forbidden memory space) are supposed to make this function crash. </dd></dl>

</div>
</div>
<a id="a3b74034df822be1f6c45484cb01f01a7" name="a3b74034df822be1f6c45484cb01f01a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b74034df822be1f6c45484cb01f01a7">&#9670;&nbsp;</a></span>ft_pow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ft_pow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_pow</b> &ndash; Power function. </p>
<p >The pow() functions compute base raised to the power exp.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td>.TODO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>base^exp.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>TODO.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 TODO. </dd></dl>

</div>
</div>
<a id="a0a1bcb2ef112f7ad073d507a0c6be4d2" name="a0a1bcb2ef112f7ad073d507a0c6be4d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1bcb2ef112f7ad073d507a0c6be4d2">&#9670;&nbsp;</a></span>ft_print_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ft_print_memory </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_print_memory</b> &ndash; .TODO. </p>
<p >Some_detailed_description.TODO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td>.TODO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TODO.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: malloc(), write(). <br  />
 TODO.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 TODO. </dd></dl>

</div>
</div>
<a id="a8ee15a511946c1397bd2bdea4aed6aee" name="a8ee15a511946c1397bd2bdea4aed6aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee15a511946c1397bd2bdea4aed6aee">&#9670;&nbsp;</a></span>ft_putchar_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ft_putchar_fd </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_putchar_fd</b> &ndash; .TODO. </p>
<p >Some_detailed_description.TODO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td>.TODO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TODO.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: write(). <br  />
 A NULL pointer parameter or a non-terminated string are supposed to make this function crash.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 TODO. </dd></dl>

</div>
</div>
<a id="ace5537837dd84bbafbe048446ac89edf" name="ace5537837dd84bbafbe048446ac89edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace5537837dd84bbafbe048446ac89edf">&#9670;&nbsp;</a></span>ft_putchar_fd_safe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ft_putchar_fd_safe </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_putchar_fd_safe</b> &ndash; TODO.. </p>
<p >Some_detailed_description.TODO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td>.TODO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Amount of chars actually printed.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: write(). <br  />
 TODO. A NULL pointer parameter or a non-terminated string are supposed to make this function crash.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 TODO. </dd></dl>

</div>
</div>
<a id="aeb112152acfc553d58d61a5df38afcde" name="aeb112152acfc553d58d61a5df38afcde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb112152acfc553d58d61a5df38afcde">&#9670;&nbsp;</a></span>ft_putendl_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ft_putendl_fd </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_putendl_fd</b> &ndash; .TODO. </p>
<p >Some_detailed_description.TODO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td>.TODO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TODO.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: write(). <br  />
 A NULL pointer parameter or a non-terminated string are supposed to make this function crash. TODO</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 TODO. </dd></dl>

</div>
</div>
<a id="a63cc0aec12256d125d3f85e472280972" name="a63cc0aec12256d125d3f85e472280972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63cc0aec12256d125d3f85e472280972">&#9670;&nbsp;</a></span>ft_putnbr_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ft_putnbr_fd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_putnbr_fd</b> &ndash; .TODO. </p>
<p >Some_detailed_description.TODO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td>.TODO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TODO.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: write(). <br  />
 A NULL pointer parameter or a non-terminated string are supposed to make this function crash.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 TODO. </dd></dl>

</div>
</div>
<a id="acefce9ac519f8f8b7d3fde33dbafe469" name="acefce9ac519f8f8b7d3fde33dbafe469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acefce9ac519f8f8b7d3fde33dbafe469">&#9670;&nbsp;</a></span>ft_putstr_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ft_putstr_fd </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_putstr_fd</b> &ndash; .TODO. </p>
<p >Some_detailed_description.TODO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td>.TODO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TODO.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: write(). A NULL pointer parameter or a non-terminated string are supposed to make this function crash. TODO</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 TODO. </dd></dl>

</div>
</div>
<a id="ac8b37f8f02a3ced682c7f1f874b1b144" name="ac8b37f8f02a3ced682c7f1f874b1b144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b37f8f02a3ced682c7f1f874b1b144">&#9670;&nbsp;</a></span>ft_putstr_fd_safe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ft_putstr_fd_safe </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_putstr_fd_safe</b> &ndash; TODO. </p>
<p >Some_detailed_description. TODO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td>. TODO</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Amount of chars actually printed.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: write(). <br  />
 TODO. <br  />
 A NULL pointer parameter or a non-terminated string are supposed to make this function crash.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 TODO. </dd></dl>

</div>
</div>
<a id="aa65c9de65051c8c589286cf133c4a1f4" name="aa65c9de65051c8c589286cf133c4a1f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa65c9de65051c8c589286cf133c4a1f4">&#9670;&nbsp;</a></span>ft_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ** ft_split </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_split</b> &ndash; Split string according to delimiter char. </p>
<p >Allocates (with malloc(3)) and returns an array of strings obtained by splitting ’s’ using the character ’c’ as a delimiter. <br  />
 The array must end with a NULL pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>- The string to be splitted.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>- The character that will act as delimiter to determine the resulting splitted substrings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The array of new strings resulting from the split. The last element of this array is always NULL. <br  />
 NULL if the allocation fails.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: malloc(), free(). <br  />
 A NULL pointer parameter or a non-terminated string are supposed to make this function crash.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 Contigous delimiter chars produce no substrings at all. <br  />
 This function is supposed to return a single element array (with NULL value) when argument s is an empty string. </dd></dl>

</div>
</div>
<a id="aa6d0c2d180f32ee585485e1a1ce3d55d" name="aa6d0c2d180f32ee585485e1a1ce3d55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d0c2d180f32ee585485e1a1ce3d55d">&#9670;&nbsp;</a></span>ft_strchr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ft_strchr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_strchr</b> &ndash; Locate character in string (left to right). </p>
<p >The <a class="el" href="libft_8h.html#aa6d0c2d180f32ee585485e1a1ce3d55d" title="ft_strchr – Locate character in string (left to right).">ft_strchr()</a> function locates the first occurrence of c (converted to a char) in the string pointed to by s. The terminating null character is considered to be part of the string; therefore if c is &lsquo;\0&rsquo;, the functions locate the terminating &lsquo;\0&rsquo;. <br  />
 The strrchr() function is identical to strchr(), except it locates the last occurrence of c.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>- The string that will be scanned.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>- The char to look for in s.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The functions <a class="el" href="libft_8h.html#aa6d0c2d180f32ee585485e1a1ce3d55d" title="ft_strchr – Locate character in string (left to right).">ft_strchr()</a> and <a class="el" href="libft_8h.html#a49c260cf80f9997975d6f3ec74ead582" title="ft_strrchr – Locate character in string (right to left).">ft_strrchr()</a> return a pointer to the located character, or NULL if the character does not appear in the string.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>TODO. A NULL pointer parameter or a non-terminated string are supposed to make this function crash. </dd></dl>

</div>
</div>
<a id="a2ac2079a4250507c9af75d696f2ae476" name="a2ac2079a4250507c9af75d696f2ae476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac2079a4250507c9af75d696f2ae476">&#9670;&nbsp;</a></span>ft_strdup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ft_strdup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_strdup</b> &ndash; Saves a copy of a string. </p>
<p >The <a class="el" href="libft_8h.html#a2ac2079a4250507c9af75d696f2ae476" title="ft_strdup – Saves a copy of a string.">ft_strdup()</a> function allocates sufficient memory for a copy of the string s1, does the copy, and returns a pointer to it. <br  />
 The pointer may subsequently be used as an argument to the function free().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s1</td><td>- The string to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, <a class="el" href="libft_8h.html#a2ac2079a4250507c9af75d696f2ae476" title="ft_strdup – Saves a copy of a string.">ft_strdup()</a> function returns a pointer to the newly allocated string copy. <br  />
 If there is an error, it returns a NULL pointer.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: malloc(). <br  />
 A NULL pointer parameter or a non-terminated string are supposed to make this function crash. </dd></dl>

</div>
</div>
<a id="ada722cffd2c6c8169ae339afd0f9763c" name="ada722cffd2c6c8169ae339afd0f9763c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada722cffd2c6c8169ae339afd0f9763c">&#9670;&nbsp;</a></span>ft_striteri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ft_striteri </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(unsigned int, char *)&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_striteri</b> &ndash; Modify a string applying a function to each of its chars. </p>
<p >Applies the function ’f’ on each character of the string passed as argument, passing its index as first argument. Each character is passed by address to ’f’ to be modified if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td>.TODO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>A NULL pointer parameter or a non-terminated string are supposed to make this function crash.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 TODO. </dd></dl>

</div>
</div>
<a id="a91e6e3e428bcc9f2291b700e1829b82b" name="a91e6e3e428bcc9f2291b700e1829b82b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e6e3e428bcc9f2291b700e1829b82b">&#9670;&nbsp;</a></span>ft_strjoin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ft_strjoin </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_strjoin</b> &ndash; Concatenates two strings resulting in new string. </p>
<p >Allocates (with malloc()) and returns a new string, which is the result of the concatenation of ’s1’ and ’s2’.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s1</td><td>- First string (prefix).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s2</td><td>- Second string (suffix).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new string. <br  />
 NULL if the allocation fails.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: malloc(). <br  />
 A NULL pointer parameter or a non-terminated string are supposed to make this function crash. TODO</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 TODO </dd></dl>

</div>
</div>
<a id="a7531453313e0cbfde6fe51662c9c3208" name="a7531453313e0cbfde6fe51662c9c3208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7531453313e0cbfde6fe51662c9c3208">&#9670;&nbsp;</a></span>ft_strlcat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ft_strlcat </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_strlcat</b> &ndash; Concatenate string. </p>
<p ><a class="el" href="libft_8h.html#a7531453313e0cbfde6fe51662c9c3208" title="ft_strlcat – Concatenate string.">ft_strlcat()</a> appends string src to the end of dst. It will append at most dstsize - strlen(dst) - 1 characters. It will then NUL-terminate, unless dstsize is 0 or the original dst string was longer than dstsize (in practice this should not happen as it means that either dstsize is incorrect or that dst is not a proper string). <br  />
 <a class="el" href="libft_8h.html#a12f759eb9793cf306fede66d0b7de0fc" title="ft_strlcpy – Copies a string.">ft_strlcpy()</a> and <a class="el" href="libft_8h.html#a7531453313e0cbfde6fe51662c9c3208" title="ft_strlcat – Concatenate string.">ft_strlcat()</a> take the full size of the destination buffer <br  />
 and guarantee NUL-termination if there is room. <br  />
 Note that room for the NUL should be included in dstsize.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td>.TODO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="libft_8h.html#a12f759eb9793cf306fede66d0b7de0fc" title="ft_strlcpy – Copies a string.">ft_strlcpy()</a> and <a class="el" href="libft_8h.html#a7531453313e0cbfde6fe51662c9c3208" title="ft_strlcat – Concatenate string.">ft_strlcat()</a> functions return the total length of the string they tried to create. <br  />
 For strlcpy() that means the length of src. <br  />
 For strlcat() that means the initial length of dst plus the length of src.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>TODO. <br  />
 A NULL pointer parameter or a non-terminated string are supposed to make this function crash.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 It must NOT be assumed that src is NUL terminated. <br  />
 It must NOT be assumed that dst is NUL terminated. First it must be checked (within dstsize) that a '\0' is found in dst. If no NUL character is found, the function must return inmediately without modifying dst (it would make no sense otherwise because there is no way of knowing where is the end of dst). <br  />
 If there is a NUL char in dst, then the copy from source can start. <br  />
 The copy of chars from src to dst is done while (d &lt; dstsize - 1) but can be aborted if (src[s] == '\0') (d starts at the position where '\0' is found in dst; s starts at 0). Finally dst is ALWAYS NUL terminated, either at position dstsize - 1 (i.e. the case when src doesn't really fit inside dst) or when corresponding given the break of the while loop triggered by the if (src[s] == '\0'). <br  />
 Notice that src might not be NUL terminated. The concatenation would end <br  />
 only when !(d &lt; dstsize - 1). <br  />
 In every case the return is: <br  />
 TODO <br  />
 In this case there are two possibilities: <br  />
 There is room for the whole src to fit + NUL char to fit in dst (always according to dstsize and the actual position of the first NUL character in dst); or <br  />
 TODO <br  />
 When a 0 (or negative) dstsize is passed it must not copy any chars. This is a problem when evaluating the if condition because size_t is unsigned and must be casted with (signed) in order for the condition to behave as expected. <br  />
 Also, the returned value is NOT the original dst size + ft_strlen(src) but dstsize parameter + ft_strlen(src). </dd></dl>

</div>
</div>
<a id="a12f759eb9793cf306fede66d0b7de0fc" name="a12f759eb9793cf306fede66d0b7de0fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f759eb9793cf306fede66d0b7de0fc">&#9670;&nbsp;</a></span>ft_strlcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ft_strlcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_strlcpy</b> &ndash; Copies a string. </p>
<p ><a class="el" href="libft_8h.html#a12f759eb9793cf306fede66d0b7de0fc" title="ft_strlcpy – Copies a string.">ft_strlcpy()</a> copies up to dstsize - 1 characters from the string src to dst, NUL-terminating the result if dstsize is not 0. <br  />
 <a class="el" href="libft_8h.html#a12f759eb9793cf306fede66d0b7de0fc" title="ft_strlcpy – Copies a string.">ft_strlcpy()</a> and <a class="el" href="libft_8h.html#a7531453313e0cbfde6fe51662c9c3208" title="ft_strlcat – Concatenate string.">ft_strlcat()</a> take the full size of the destination buffer and guarantee NUL-termination if there is room. <br  />
 Note that room for the NUL should be included in dstsize.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td>.TODO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="libft_8h.html#a12f759eb9793cf306fede66d0b7de0fc" title="ft_strlcpy – Copies a string.">ft_strlcpy()</a> and <a class="el" href="libft_8h.html#a7531453313e0cbfde6fe51662c9c3208" title="ft_strlcat – Concatenate string.">ft_strlcat()</a> functions return the total length of the string they tried to create. <br  />
 For strlcpy() that means the length of src. <br  />
 For strlcat() that means the initial length of dst plus the length of src.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>TODO. <br  />
 A NULL pointer parameter or a non-terminated string are supposed to make this function crash.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 When a 0 dstsize is passed it must not copy any chars. This must be checked separately to avoid entering the while loop because the expression: <br  />
 i &lt; dstsize - 1 <br  />
 Does not work because of the unsignedness of dstsize. This worked: <br  />
 while (dstsize != 0 &amp;&amp; i &lt; dstsize - 1 &amp;&amp; src[i] != '\0'). </dd></dl>

</div>
</div>
<a id="abbb8c6c4ed85d892e7f1509f65f5768a" name="abbb8c6c4ed85d892e7f1509f65f5768a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb8c6c4ed85d892e7f1509f65f5768a">&#9670;&nbsp;</a></span>ft_strlen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ft_strlen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_strlen</b> &ndash; Gets length of a nul-terminated C string. </p>
<p >Counts characters (from left to right) before the NUL character '\0'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>- The nul-terminated C string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the string.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>A NULL pointer parameter or a non-terminated string are supposed to make this function crash. </dd></dl>

</div>
</div>
<a id="a668b60557bfc9d60c2d3ccda8afadf49" name="a668b60557bfc9d60c2d3ccda8afadf49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668b60557bfc9d60c2d3ccda8afadf49">&#9670;&nbsp;</a></span>ft_strmapi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ft_strmapi </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char(*)(unsigned int, char)&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_strmapi</b> &ndash; Apply a funtion to each char of a string. </p>
<p >Applies the function ’f’ to each character of the string ’s’, and passing its index as first argument to create a new string (with malloc()) resulting from successive applications of ’f’.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td>.TODO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string created from the successive applications of ’f’. <br  />
 Returns NULL if the allocation fails.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: malloc(). <br  />
 A NULL pointer parameter or a non-terminated string are supposed to make this function crash. TODO</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 TODO. </dd></dl>

</div>
</div>
<a id="a9d2fe792187aa4ed08e5864fb2c4d6dc" name="a9d2fe792187aa4ed08e5864fb2c4d6dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2fe792187aa4ed08e5864fb2c4d6dc">&#9670;&nbsp;</a></span>ft_strncmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ft_strncmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_strncmp</b> &ndash; Compare two strings. </p>
<p >The ft_strcmp() function compares the two strings s1 and s2. The comparison is done using unsigned characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s1</td><td>- First string.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s2</td><td>- Second string.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>- Amount of bytes to compare from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an integer indicating the result of the comparison, as follows: <br  />
 0, if the s1 and s2 are equal; <br  />
 A negative value if s1 is less than s2; <br  />
 A positive value if s1 is greater than s2. <br  />
 Specifically the returned value comes from the first different char found as the difference between the numeric value of s1's char minus the numeric value of s2's char.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>TODO. <br  />
 A NULL pointer parameter or a non-terminated string are supposed to make this function crash.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 TODO. </dd></dl>

</div>
</div>
<a id="ae00229613cc0bf361e86dca72ad92591" name="ae00229613cc0bf361e86dca72ad92591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae00229613cc0bf361e86dca72ad92591">&#9670;&nbsp;</a></span>ft_strnstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ft_strnstr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_strnstr</b> &ndash; Locate a substring in a string. </p>
<p >The <a class="el" href="libft_8h.html#ae00229613cc0bf361e86dca72ad92591" title="ft_strnstr – Locate a substring in a string.">ft_strnstr()</a> function locates the first occurrence of the null-terminated string needle in the string haystack, where not more than len characters are searched. Characters that appear after a &lsquo;\0&rsquo; character are not searched.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td>.TODO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If needle is an empty string, haystack is returned. <br  />
 If needle occurs nowhere in haystack, NULL is returned. <br  />
 Otherwise a pointer to the first character of the first occurrence of needle is returned.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>TODO. <br  />
 A NULL pointer parameter or a non-terminated string are supposed to make this function crash.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 TODO. </dd></dl>

</div>
</div>
<a id="a49c260cf80f9997975d6f3ec74ead582" name="a49c260cf80f9997975d6f3ec74ead582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49c260cf80f9997975d6f3ec74ead582">&#9670;&nbsp;</a></span>ft_strrchr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ft_strrchr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_strrchr</b> &ndash; Locate character in string (right to left). </p>
<p >The <a class="el" href="libft_8h.html#aa6d0c2d180f32ee585485e1a1ce3d55d" title="ft_strchr – Locate character in string (left to right).">ft_strchr()</a> function locates the first occurrence of c (converted to a char) in the string pointed to by s. The terminating null character is considered to be part of the string; therefore if c is &lsquo;\0&rsquo;, the functions locate the terminating &lsquo;\0&rsquo;. <br  />
 The strrchr() function is identical to strchr(), except it locates the last occurrence of c.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>- The string that will be scanned.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>- The char to look for in s.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The functions <a class="el" href="libft_8h.html#aa6d0c2d180f32ee585485e1a1ce3d55d" title="ft_strchr – Locate character in string (left to right).">ft_strchr()</a> and <a class="el" href="libft_8h.html#a49c260cf80f9997975d6f3ec74ead582" title="ft_strrchr – Locate character in string (right to left).">ft_strrchr()</a> return a pointer to the located character, or NULL if the character does not appear in the string.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>TODO. A NULL pointer parameter or a non-terminated string are supposed to make this function crash. </dd></dl>

</div>
</div>
<a id="a60352c5b39fab08469b3e28131a79e25" name="a60352c5b39fab08469b3e28131a79e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60352c5b39fab08469b3e28131a79e25">&#9670;&nbsp;</a></span>ft_strtrim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ft_strtrim </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_strtrim</b> &ndash; Trims string resulting in new string. </p>
<p >Allocates (with malloc()) and returns a copy of ’s1’ with the characters specified in ’set’ removed from the beginning and the end of s1 string. Parameter s1 is scanned left to right and right to left removing any character that is also found in set until a character NOT included in set is found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s1</td><td>- The string to be trimmed.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">set</td><td>- The string containing the chars that will be trimmed from s1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The trimmed string. <br  />
 NULL if the allocation fails.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: malloc(). <br  />
 A NULL pointer parameter or a non-terminated string are supposed to make this function crash.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 TODO. </dd></dl>

</div>
</div>
<a id="a78c402cbf3d55b1374693c3b7d34f71d" name="a78c402cbf3d55b1374693c3b7d34f71d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c402cbf3d55b1374693c3b7d34f71d">&#9670;&nbsp;</a></span>ft_substr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ft_substr </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_substr</b> &ndash; Create new substring from original string. </p>
<p >Allocates (with malloc()) and returns a substring from the string ’s’. The substring begins at index ’start’ and is of maximum size ’len’.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>- The string from which to create the substring.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>- The start index of the substring in the string ’s’.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>- The maximum length of the substring.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly allocated substring. <br  />
 NULL if the allocation fails.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: malloc(). <br  />
 A NULL pointer parameter or a non-terminated string are supposed to make this function crash.TODO</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 Before starting the copy of the substr, the following must be addressed: <br  />
 1 If s = "" or start &gt;= ft_strlen(s), it'd only make sense to return "" <br  />
 2 If (start + len &gt; ft_strlen(s)) len must be modified to len = ft_strlen(s) - start before allocating memory for the substring. </dd></dl>

</div>
</div>
<a id="ab86e5297914753b6c82d7e3c3020ce17" name="ab86e5297914753b6c82d7e3c3020ce17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab86e5297914753b6c82d7e3c3020ce17">&#9670;&nbsp;</a></span>ft_tolower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ft_tolower </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_tolower</b> &ndash; If uppercase, changes to lowercase. </p>
<p >If argument is an uppercase letter, this function returns its lowercase version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>- The character to evaluate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If argument char is uppercase, the return is its lowercase version. <br  />
 Otherwise the return is the original char c. </dd></dl>

</div>
</div>
<a id="aef116be7b5bceafff4b59f20a4433d12" name="aef116be7b5bceafff4b59f20a4433d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef116be7b5bceafff4b59f20a4433d12">&#9670;&nbsp;</a></span>ft_toupper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ft_toupper </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_toupper</b> &ndash; If lowercase, changes to uppercase. </p>
<p >If argument is a lowercase letter, this function returns its uppercase version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>- The character to evaluate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If argument char is lowercase, the return is its uppercase version. <br  />
 Otherwise the return is the original char c. </dd></dl>

</div>
</div>
<a id="a7db52ad9f695362b5e2cc539c83b85c4" name="a7db52ad9f695362b5e2cc539c83b85c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db52ad9f695362b5e2cc539c83b85c4">&#9670;&nbsp;</a></span>ft_uitoa_b()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ft_uitoa_b </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in_caps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_uitoa_b</b> &ndash; .TODO. </p>
<p >Some_detailed_description.TODO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td>.TODO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TODO.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: malloc(). <br  />
 A NULL pointer parameter or a non-terminated string are supposed to make this function crash. TODO</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 TODO. </dd></dl>

</div>
</div>
<a id="af747f6fc58589f60ad415f306b2c96d9" name="af747f6fc58589f60ad415f306b2c96d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af747f6fc58589f60ad415f306b2c96d9">&#9670;&nbsp;</a></span>ft_ultoa_b()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ft_ultoa_b </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in_caps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ft_ultoa_b</b> &ndash; .TODO. </p>
<p >Some_detailed_description.TODO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TODO.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>EXTERNAL FUNCTION USED: malloc(). <br  />
 A NULL pointer parameter or a non-terminated string are supposed to make this function crash.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implementation notes: <br  />
 TODO. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
